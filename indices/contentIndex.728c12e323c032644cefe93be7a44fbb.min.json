{"/":{"title":"","content":"# My notes\n\nBasically everything I write is in Markdown using [Obsidian](https://obsidian.md/). The main reasons are that it uses Markdown and lets me link documents and view them as a graph.\n\nThis website is created using Quartz, a Hugo based tool that turns Obsidian notes into HTML.\n\nMost of the stuff I write is not meant for others to read. \n\nThese are some that might be more readable:\n- [Knee ability zero](Zettelkasten/Knee%20ability%20zero.md)\n\n","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/3D-printing":{"title":"3D printing","content":"# 3D printing\nThis could bring manufacturing closer to markets of products instead of parts being shipped globally. More on demand products manufacturing / variable production rates.\n\nPretty slow and quality is still worse than other plastic manufacturing.\n\n\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-12\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/3sum":{"title":"3sum ","content":"# 3sum\nProblem: Find 3 unique indices in array, a, s.t. a[i] + a[j] + a[k] == 0\n\nSolution (more direct from 2sum):\n- sort array\n- one for loop to fix the first of the triple\n- inner standard 2-sum \nSolution:\n- O(n^2) solution with two points i = 0, and j = i + 1\n- Iterate both i and j until they are not equal to their previous value\n- taret value of -a[i] - a[j] can be found using a previously built [[Hash map]] \n\t- or third pointer iterating backwards depending on target value\n\t\nImplementation:\n```c++\nvector\u003cvector\u003cint\u003e\u003e ans;\nif (nums.size() == 0) return ans;\nsort(nums.begin(), nums.end());\nif (nums[0] \u003e 0) return ans;\n\nmap\u003cint, int\u003e m;\nfor (int i = 0; i \u003c nums.size(); ++i) m[nums[i]] = i;\n\nfor (int i = 0; i \u003c nums.size(); ++i) {\n\tfor (int j = i+1; j \u003c nums.size(); ++j) {\n\t\tint target = -nums[i] - nums[j];\n\t\tif (m.count(target) != 0 \u0026\u0026 m[target] \u003e j)\n\t\t\tans.push_back({nums[i], nums[j], target});\n\t\twhile (j \u003c nums.size() - 1 \u0026\u0026 nums[j] == nums[j+1]) ++j;\n\t}\n\twhile (i \u003c nums.size() - 1 \u0026\u0026 nums[i] == nums[i+1]) ++i;\n}\nreturn ans;\n```\n## References\n1. https://leetcode.com/problems/3sum/discuss/?currentPage=1\u0026orderBy=most_votes\u0026query=\n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-09\ntags: [[Programming question]], [[Two pointer]], [[Leetcode]]\n","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Adress-spaces":{"title":"Adress spaces","content":"# Adress spaces\nAdress space contains the code, stack, and heap.\n\n## dynamic relocation\neach program has a base and bound register (implemented by hardware) \n- hardware adds base to va to get pa and double checks its legal within bound\n\nA single bit lets the processor know if it is in user mode or priviledged mode.\n\ninternal fragmentation\n## Segmentation\ntop two bits: \n- 00 -\u003e code\n- 01 -\u003e heap\n- 10 -\u003e \n\n### Stack\n- va (offset) - max_size (bound) + base (base address)\n\nexternal fragementation is the space wasted between segments\n\n## Paging\nSplit memory into fixed sizes segments. \n- Os keeps a per-process data structure called a page table to allow address translation\n\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-03-18\ntags: [[Operating System]], [[Operating Systems - CS 350]]","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Algorithmic-reductions":{"title":"Algorithmic reductions","content":"# Algorithmic reductions\nUsing existing algorithms to solve new problems.\n\nSolving X problem using algorithm Y which we treet as a [[Black box]] that solves problem Z correctly.\n- It is important to be able to tree Y as a black box and not worry about it's internals\n- A good approach is to view it as a magic solution\n\nRecursion is an example of reduction\n- If problem can be solved directly -\u003e solve it\n- Else, reduce the problem to one or more instance of **the same problem**\n- A hard part of being comfortable with recursion is [[Black box]]ing the recursive magic (inductive hypothesis). We only care about reducing the problem - the recursion *fairy* will solve it\n\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-16\ntags: [Algorithms - CS 341](Zettelkasten/Algorithms%20-%20CS%20341.md), [Algorithms](Algorithms), ","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Algorithms-CS-341":{"title":"","content":"U---\ntitle: \"Algorithms - CS 341\"\ndraft: false\n---\n# Algorithms - CS 341\n\nGeneral paradigms\n- divide and conquer, [Greedy algorithms](Greedy%20algorithms.md), [Dynamic programming](Dynamic%20programming.md), reductions\n\n## Content\n[[Models of computation]]\nAlgorithmic paradigms\n-  [[Algorithmic reductions]]\n- [[Divide and conquer]]\n- [Greedy algorithms](Greedy%20algorithms.md)\n- [Dynamic programming](Zettelkasten/Dynamic%20programming.md)\n- [[Graph algorithms]]\n\n[[Solving recurrence relations]]\n\n[[Polynomial reduction]]\n[[NP and NP-Complete]]\n\nFinal exam review: [[cs341 - final exam review]]\n## Grading\n- 8 written assignments (6% each) 48% total\n- 2 programming assignments (6% each) 12% total\n- midterm 15% \n- final 25%\n\n*must pass midterm + final weighted average*\n\n\n### References\n1. Algorithms by Erikson: https://jeffe.cs.illinois.edu/teaching/algorithms/\n\n---\nstatus:\ndate: 2022-01-06\ntags: [Course outline](Zettelkasten/Course%20outline.md)","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Andrew-Huberman-nutrition":{"title":"Andrew Huberman nutrition","content":"# Andrew Huberman nutrition\nAndrew Huberman's diet and supplement routine everybody! (-:\n\nSpecialty: \nFor last +10 years: Intermittent Fasting (12 - 16 hours in total with sleep) after waking up until noon.\n\ntl;dr version: \t\n- Get up and hydrate -\u003e Fast till noon -\u003e Train at the end of the fast -\u003e Eat at noon (if trained eat some carbs and protein; if not reduce the carbs to about half its size) -\u003e In the afternoon eat something low carb-ish -\u003e In the evening eat carbs (still in moderation, not some huge portions)\n\n\nMorning\n- Gets up early and hydrates - puts salt and lemon in water to delay the hunger\nNote: supposedly a lot of people who follow low-carb diets are sodium deficient, so they should follow this advice as well\n- Caffeine (Coffee or Yerba mate) 1,5 - 2 hours after waking to avoid crash later\n- Fasts for 6 - 8 hours until noon\n     ‚Ä¢ Sometimes he breaks that fast and eats something sooner like 4 Eggs - it happens, after all he is just a hu(ber)man :-)\n- He does training late in the morning\n\t     \n   \nNoon\nFirst meal of the day:\n- He eats mostly based on appetite\n- Almost always low-carb meal - more mental clarity provided that glycogen storages have been repacked from the previous day or so (see Dinner part)\n\n- (Rib-eye) Steak or Ground Beef, Olive oil, some Brazil Nuts, maybe some Veggies (Tomatoes, Avocados, Broccoli, Spinach...)\n    ‚Ä¢ However if training will be really hard like some (heavy) resistance training then he eats carbs (starches) and fruits with the meal, for example.: Bowl of Rice or Bowl of Oatmeal + Small Pot of Butter\n\t\nSupplements \n- Drinks Athletic Greens\n- EEAs after training\n\n\nAfternoon\t\n- Hydrates\n- Eats nuts (he didn't mention if he eats seeds or not as well) like Almonds\n\t\nSupplements\n- Athletic Greens\n- Whey protein\n\n\nDinner\t\n- If he eats too much meat near bed time, the quality of his sleep deteriorates - most likely because the gastric clearance is too long - so he doesn't do that!\n- Walks after or before dinner\n- Eats mostly carbs - starches\n    ‚Ä¢ Bowl of Pasta or Rice, Salad, sometimes fish like Tuna fish or Salmon\n-  Goes to sleep around 10:30 - 11:00 PM (22:30 - 23:00) - I guess he eats 2-3 hours before sleep?\n\n\nSupplements in general\n- He is not fond of pro/pre-biotics supplements, instead he suggests:\n\t‚Ä¢ 2-4 servings of low-sugar fermented foods a day: kimchi, sauerkraut, natto etc. as those greatly decrease the number of inflammatory markers in the so-called \"Inflammatome\"\n- Multivitamin - B-vitamins help to metabolize foods more quickly\n- Boron 2-4 mg\n- Vitamin K2\n- Athletic Greens\n- Whey protein\n- EEAs after training\n- Fish Oil - at least 2 g of EPA (Thorne Fish Oil + Tablespoon of the Carlson's Fish Oil with the lemon flavour)  - antidepressant effects, blood lipid profile effects, skin health, mental health‚Ä¶ - he takes it as he isn't really fond of the taste of fish\n- From time to time he takes:\n    ‚Ä¢ Vitamin E, CLA, Green Tea Extract, Garlic Extract\n\n- He didn't mention any other supplements in this video, however I know he is taking some additional supplements/nootropics like Magnesium L-Threonate, L-Theanine etc. More on that here:\nhttps://medium.com/@podclips/dr-andrew-hubermans-supplement-recommendations-7491483e778b\n\n@Andrew Huberman (or anyone else really)\nIf you see this comment, please correct me if I wrote something wrong :-)\n## References\n1. https://www.youtube.com/watch?v=LiF8M52wyy4\n\n---\nstatus: #üü£\ndate: 2021-11-28\ntags: [[Health]] ","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Ass-to-grass-split-squat":{"title":"Ass to grass split squat","content":"# Ass to grass split squat\nATG split squat\n\n## Technique\n1. Find your step length. Too short doesn't allow depth. Too far doesn't allow knees over toes.\n\t2. back toes should be still curled not rolling over. back knee should not touch floor.\n2. Elevate front foot if it is too hard to reach bottom. Add assistance for arm if still too hard. If it is still too hard go back to earlier exercises to build prerequisite strength.\n3. Lower down till full in bottom position, fully pause, come back up maintaining form.\n\n![](Zettelkasten/Pasted%20image%2020220818115418.png)\n## Why\nImproves knee stability and increases tendon health and mobility. Also very good for hip flexor mobility. \n\nAuthor of the book views this as the most important exercise for knee health. Previous exercises are to build up to this. He also maintains his ability to do the splits solely via this exercise.\n\n\n### References\n1. \n\n---\nstatus: #üå±             \ndate: 2022-08-18           \ntags: [Knee ability zero](Knee%20ability%20zero.md)           ","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Big-O-notation":{"title":"Big O notation","content":"# Big O notation\n\n$f(n) \\in O(g(n))$ If the exists constant $c$ and $n_0$ s.t. if $n \u003e n_0$ then $f(n) \u003c c \\cdot g(n)$\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-16\ntags: [Algorithms - CS 341](Zettelkasten/Algorithms%20-%20CS%20341.md), [Algorithms](Algorithms)","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Binary-tree-maximum-path-sum":{"title":"Binary tree maximum path sum ","content":"# Binary tree maximum path sum\nProblem: Find the maximum path sum in a binary tree\n\nSolution:\n- at any node, best sum fromt this node is \n\t- max left path: max(0, left-path-max) \n\t- max right path: max(0, right-path-max)\n\t- node max = node.value + max(left, right)\n\nImplementation:\n```c++\nint ans = INT_MIN;\nint dfs(TreeNode *root) {\n\tif (!root) return 0;\n\tint left = max(0, dfs(root-\u003eleft));\n\tint right = max(0, dfs(root-\u003eright));\n\tans = max(root-\u003eval + left + right, ans);\n\treturn root-\u003eval + max(left, right);\n}\nint maxPathSum(TreeNode* root) {\n\tdfs(root);\n\treturn ans;\n}\n```\n\n## References\n1. \n\n---\nsatus: #üü¶ #üåû\ndate: 2021-12-01\ntags: [[Programming question]], [[Leetcode]], [[depth first search]]\n","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Blind-75-tracking-list":{"title":"Blind 75 tracking list ","content":"# Blind 75 tracking list\n1. [x] Two Sum \n2. [x] Longest substring without repeating characters\n3. [x] [[Longest palindrome substring]]\n4. [x] [[Container with most water]]\n5. [x] [[3sum]]\n6. [x] [[Remove nth element from back of list]]\n7. [x] [[Valid parenthesis]]\n8. [x] Merge two sorted lists\n9. [ ] [[Merge k-sorted lists]]\n10. [ ] Search in rotated sorted array\n11. [ ] Combination sum\n12. [ ] Rotate image\n13. [ ] Group anagrams\n14. [ ] Maximum subarray\n15. [ ] Spiral matrix\n16. [x] [[Jump game]]\n17. [x] [[Merge intervals]]\n18. [x] [[Insert intervals]]\n19. [x] [[Unique paths]]\n20. [ ] [[Climbing stairs]]\n21. [x] Set matrix zeroes\n22. [x] [[Minimum window substring]]\n23. [x] [[Word search]]\n24. [x] [[Decode ways]]\n25. [x] [[Validate binary search tree]]\n26. [x] [[Same tree]]\n27. [x] [[Level order traversal]]\n28. [x] [[Maximum depth of a binary tree]]\n29. [ ] [[ Construct binary tree from perorder and inorder traversal]]\n30. [x] [[Best time to buy and sell stock]]\n31. [x] [[Binary tree maximum path sum]]\n42. [x] [[House robber]]\n49. [x] [[House robber ii]]\n64. [x] [[Longest Increasing Subsequence]]\n75. [x] [[Coin change]]\n\n## Not in unsorted blind 75\n- [x] [[Combination sum iv]]\n\n## References\n1. Blind 75 problems list: https://leetcode.com/list/xi4ci4ig/ \n\n---\nstatus: #ü¶¥\ndate: 2021-11-09\ntags: [[Leetcode]], [[Programming question]]\n","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Bowling-problem":{"title":"Bowling problem ","content":"# Bowling problem\nProblem: List of bowling pins with numeric scores, you can hit a bowling pin to get it's points or hit two adjacent ones to get their product\n\nSolution:\nThis is a maximization problem where we want to maximize over possible combinations\n- notice we can brute force locally (if we know max scores of a suffix we can find max solution locally)\n\nUsing the [[Recursive algorithm]] design:\n1. **Subproblem:** DP(i) = max score possible with pins `i, ..., n - 1`\n2. **Original problem:** DP(0)\n3. **Relate:** DP(i) = max{DP(i+1), DP(i+1) + $v_i$,  DP(i+2) + $v_i \\cdot v_{i+1}$}\n4. **Topological:** Decreasing i (smaller i depends on larger i)\n5. **Base:** DP(n) = 0\n\n## References\n1. mit lecture: https://www.youtube.com/watch?v=r4-cftqTcdI\n\n---\nstatus: #üü¶\ndate: 2021-11-23\ntags: [[Recursive algorithm]], [[Programming question]]\n","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Boxplots":{"title":"Boxplots","content":"# Boxplots\n![](Zettelkasten/Pasted%20image%2020220113104552.png)\n\nHow to make one\n1. draw a box with sides at q(0.25) and q(0.75)\n2. draw a line in the box at the median\n3. draw lines where the smallest/largest observation is between 1.5 \\* IQR\n4. connext the box to the lines above\n5. label points beyond the whiskers (these represent outliers) \n\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-13\ntags: [Statistics](Statistics), [Statistics 241](Statistics%20241.md), [Graphical data summaries](Graphical%20data%20summaries.md)","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/CAP-theorem":{"title":"CAP theorem ","content":"# CAP theorem\n\n## Theorem:\nA distributed system can only ever satisfy 2 of the following 3:\n- availability, consistency, partitian tolerance\n\nAvailability: any live node in the system must respond to requests (cannot ignore them)\n\nConsistency: reads to a node must return the freshest value (a write followed by a read to any node always returns the newly written value)\n\nPartitian tolerance: Any number of disconnections between nodes in the system can be handled\n\n**Proof the 3 can't ever hold:**\n- create a system with total partitional failure (nodes are disconnected)\n- write to node1\n- read from node2\n\t- this read must respond, node1 can't communicate with node2 hence node2 responds with a *stale* value\n\nHence we have shown for any distributed system there exists a configuration where the 3 cannot simultaneuosly hold.\n\n## References\n1. visual proof: https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/\n\n---\nstatus: #üåû #üü´\ndate: 2021-11-17\ntags: [[Databases]], [[Distributed systems]]\n","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Central-limit-theorem":{"title":"Central limit theorem","content":"# Central limit theorem\nThe mean of samples taken from a distribution (with defined distribution mean and variance) follow a normal distribution. This also works for the sum of the sample. \n\nDefinition:\n![[Pasted image 20220127212715.png]]\n\n![](Zettelkasten/Pasted%20image%2020220111142227.png)\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-11\ntags: [Statistics 241](Statistics%20241.md), [Probability](Probability), [Statistics](Statistics)","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/China-demographic-collapse":{"title":"China demographic collapse","content":"# China demographic collapse\n\nChina had lot's of growth with a population that didn't grow along with it. They are facing a population crisis where there isn't enough economically productive workers.\n\nThe real estate market in China operates under the assumption the population is growing, but the home-buying demographic is going to shrink rapidly in the near future.\n\n\n### References\n1. https://www.youtube.com/watch?v=vTbILK0fxDY\u0026t=644s\n\n---\nstatus: #üå± \ndate: 2022-01-22\ntags: [[Economics]]","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Climbing-stairs":{"title":"Climbing stairs ","content":"# Climbing stairs\nProblem:\n\nSolution:\n\nImplementation:\n```c++\n\n```\n## References\n1. \n\n---\nsatus: #üü¶ #üå± \ndate: 2021-11-13\ntags: [[Programming question]], [[Leetcode]], [[Dynamic programming]]\n","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Codeforces-training":{"title":"Codeforces training","content":"# Codeforces training\n\n## Roadmap\nNo real structure, do a lot of Div 2 virtuals + atcoder cyans for now.\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-04-26\ntags: [[Motivation for competitive programming]], [[Competitive programming]], [[Algorithms]]","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Coin-change":{"title":"Coin change ","content":"# Coin change\nProblem: given list of coins minimum number of coins needed to make amount, or -1 if impossible\n\nSolution:\n- dp solution\n- min of amount = 1 + min(amount - coins[i]) for all i\n- note: some are going to be impossible, so for implemntation need to differentiate between already solved impossible and not solved\n\t- i.e, don't use -1 for both impossible and not solved\n\nImplementation:\n```c++\nint go(vector\u003cint\u003e\u0026 coins, vector\u003cint\u003e\u0026 memo, int amount) { \n\tif (amount \u003c 0) return -1;\n\tif (amount == 0) return 0;\n\tint \u0026ret = memo[amount];\n\tif (ret != -2) return ret;\n\n\tint ans = 1e9;\n\tfor (int i = 0; i \u003c coins.size(); ++i) {\n\t\tint t = go(coins, memo, amount - coins[i]);\n\t\tif (t != -1)\n\t\t\tans = min(ans, 1 + go(coins, memo, amount - coins[i]));\n\t}\n\tif (ans == 1e9) ans = -1;\n\tret = ans;\n\treturn ret;\n}\nint coinChange(vector\u003cint\u003e\u0026 coins, int amount) {\n\tvector\u003cint\u003e memo(amount + 1, -2);\n\treturn go(coins, memo, amount);\n}\n```\n## References\n1. https://leetcode.com/problems/coin-change/submissions/\n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-14\ntags: [[Programming question]], [[Leetcode]], [[Dynamic programming]]\n","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Commulative-distribution-function":{"title":"Emperical commulative distribution function","content":"# Cummulative distribution function\n- Empirical cummalitive distribution function (ecdf) or cdf\n\nShould be able to see the underlying histogram of data from a ecdf.\n\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-13\ntags: [Statistics](Statistics), [Statistics 241](Statistics%20241.md)","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Condition-variables":{"title":"Condition variables","content":"# Condition variables\nAllows a thread (or multiple) to sleep and wait on a condition to change to desired state thus waking one (or more) of the waiting threads up. \n\nWe need to hold the lock when signaling, this is to avoid a parent giong to sleep -\u003e a child setting the flag before parent is asleep thus waking no one -\u003e parent sleeps and is never woken up.\n- we hold the lock when calling wait since it assumes the lock is being held and frees it atomically\n\n## Producer consumer \nA condition variable can be used to signal a buffer is not empty. \n- Naive condition only works if only one producer and one consumer\n- If there are multiple consumers C1 can sleep and be woken up to consume -\u003e but first C2 consumes it thus C1 runs into an empty buffer error\n- **Mesa semantics** indicate that condition variables only **suggest** state has changed. **Hoare semantics** provide stronger guarantee that you're awaken only when it is indeed changed.\n\t- almost all systems follow **Mesa semantics** \n\t\nWe Fix the **Mesa** problem by using while loops with conditionals which ensure when a thread is woken up it rechecks that the state is indeed desired.\n\nAnother issue is if there are two consumers and a consumer and producer are asleep with a full buffer -\u003e then C1 wakes up C2 leaving P asleep we have a case where everyone is asleep\n- a consumer should **never** wake up another consumer and *vice versa*\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-03-01\ntags: [[Operating System]], [[Concurrency]], [[Operating Systems - CS 350]]","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Container-with-most-water":{"title":"Container with most water ","content":"# Container with most water\nQuestion: Given heights\\[n\\], find height\\[i\\] and height\\[j\\] which would hold most water (biggest area)\n\nSolution: \n- Greedily use two pointers starting at opposite ends, iterate the one with lesser height\n\nConcept to reach solution:\n- Need to think [[Greedily eliminating cases which cannot possibly have a solution]]\n\t- We have already found the maximum area for the minimum height between i and j \n\t- We start with the maxium width and reduce, so future pairs are less width\n\t- Since it's the minimum of the two; any other height paired with it will be found at a lesser width, and hence a lesser area\n\nImplementation:\n```c++\nint st, mx = 0; int en = height.size() - 1;\nwhile (st != en) {\n\tint mn = min(height[st], height[en]);\n\tint a = mn * (en - st);\n\tmx = max(mx, a);\n\tif (height[st] \u003c height[en]) st++;\n\telse en--;\n}\nreturn mx;\n```\n\nProof:\n```\nlet our current range be [i, j] \nlet A be the area of [i, j] \n\nAssume there exists sub-range [i', j'] != [i, j] s.t. A' \u003e A \nAssume h[i] \u003c h[j] \n\nNotice that i (is not in) [i', j'] \nsince len([i', j']) \u003c len([i, j]) \n- if i = i' -\u003e min(h[i'], h[j']) \u003c= min(h[i]) by (h[i] \u003c h[j]) \n- if i = i' -\u003e A' = h[i] * len([i, j']) \u003c h[i] * len([i, j]) = A \n- hence i != i' -\u003e [i', j'] is in [i + 1, j] \n\nHence i not in [i', j'] -\u003e [i', j'] in [i+1, j] \nHence we eliminate i greedily\n```\n\n## References\n1. https://leetcode.com/problems/container-with-most-water/\n\n---\nstatus: #üü¶ #üåû \ndate: 2021-11-09\ntags: [[Programming question]], [[Two pointer]], [[Greedy algorithms]], [[Leetcode]]\n","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Content":{"title":"Content","content":"# Content\nBroad note for entries related to media worth consuming. Could be anything, book, website, user on reddit, music, etc...\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-08-03\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Context-switch":{"title":"Context switching","content":"# Context switching\n\nVery machine dependent\n- save program counter and integer values (always)\n\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-12\ntags: [Operating Systems - CS 350](Operating%20Systems%20-%20CS%20350.md), [Operating System](Operating%20System.md)","lastmodified":"2022-08-19T04:48:18.774352914Z","tags":null},"/Zettelkasten/Course-outline":{"title":"Course outline","content":"# Course outline\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-13\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Database-internals":{"title":"Database internals","content":"# Database internals\nContent mainly based off (for now) Data base internals by Alex Petrov OReilly \n\n## Content\nThere are two main subsections; storage engines - which deals with the single node implementations related to storing data / distributed systems - which deals with implementing multiple nodes and distributing the data.\n\n### Common labels for DBMS\n1. OLTP - online transactional processing; user-facing, queries predefined and short lived\n2. OLAP - online analytical processing; commonly used for data warehousing - handle complex ad-hoc queries that are long-running\n3. HTAP hybrid transactional and analytical - properties of both\n\n### Potential DBMS architecture\nSpecific parts of DBMS are loosely defined and differ across different implementations of databaes.\n\nExample 4 layers\n- Transport \n- Query processor\n\t- query parser -\u003e query optimizer\n- Execution engine\n\t- remote / local execution\n- Storage engine\n\t- transaction / lock manager  (together responsible for concurrency control)\n\t- access methods (organize data on disk)\n\t- buffer / recovery manager\n\n### Disk-based vs. Memory based DBMS\nMemory is much faster for random access.\n- memory is more expensive - so space is limited\n- memory is not durable so it requires additional hardware for durability and is harder to manage\n\nIn-memory is not just equivalent to disk-based with large cache because of the disk-based overhead when using cache\n\n### Column vs. Row based vs. Wide column\nRow based is better when you're accessing rows, column for aggregation/analytics or things that span multiple rows.\n\nWide column - I don't really understand tbh\n- something about multiple \n\n[[Storage engines]]\n- [[B-Tree]]\n- [[File formats]]\n- [[B-Tree implementation]]\n- [[Transaction processing and recovery]]\n- [[B-Tree variants]]\n- [[Log structured storage]]\n\n[Distributed systems](Distributed%20systems)\n- [[Failure detection]]\n- [[Leader election]]\n- [[Replication and consistency]]\n- [[Anti-entropy and dissemination]]\n- [[Distributed transactions]]\n- [[Consensus]]\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-13\ntags: [[Databases]], [Programming](Programming)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Deadlocks":{"title":"Deadlocks","content":"# Deadlocks\n## Deadlocks\nIf we acquire locks in different orders we can have a deadlock situation.\n```\nThread 1:\n\tacquire lock a\n\tacquire lock b\n\tunlock a\n\tunlock b\nThread 2:\n\tacquire lock b\n\tacquire lock a\n\tunlock b\n\tunlock a\n```\n- here t1 can acquire a, t2 acquire b, then t1 stuck trying for b and t2 stuck trying for a\n- It is convention to unlock in the order acquired\n\n1. Limited access (mutual exclusion - resource shared by finite users)\n2. No preemption (once resource granted, can't be taken away)\n3. Multiple independent requests (hold and wait)\n\t1. don't ask all at once (waits for next resource while holding one)\n4. Cirularity in graph of requests\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-02-28\ntags: [[Operating System]], [[Synchronisation primitives]], [[Operating Systems - CS 350]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Determine-if-string-can-be-segmented-into-dictionary-words-Word-Break":{"title":"Determine if string can be segmented into dictionary words (Word Break) ","content":"# Determine if string can be segmented into dictionary words (Word Break)\nProblem: Given a dictionary of words return true if a string s can be broken into the words\n\nSolution:\nDynamic programming solution O(n^2)\n- sub problem: suffix starting i is breakable into dictionary words\n- relation: if substring s[i:j] is in dictionary of words and dp[j] == True then dp[i] = True\n\t- if some prefix of the suffix starting at i is a dictionary word, and the position after this prefix can be broken into words then the prefix starting at i can also be broken down\n- topology: smaller index rely on bigger one\n- base case: dp[len(s)] = true\n- original problem: dp[0]\n\nImplementation:\n```c++\n// subproblem:   dp[i] = suffix starting at i is breakable \n// relationship: dp[i] = true if s[i:j] in wordDict and dp[j] = True, for any j \u003e i \n// topology:     small i depends on larger i \n// base case:    dp[n] = true\n// original:     dp[0]\nbool dp(int i, string \u0026s, vector\u003cint\u003e\u0026 memo, set\u003cstring\u003e\u0026 d) {\n\tif (i == s.size()) return 1;\n\n\tint \u0026ret = memo[i];\n\tif (ret != -1) return ret;\n\n\tret = 0;\n\tfor (int j = i + 1; j \u003c= s.size(); ++j) {\n\t\tif (d.count(s.substr(i, j-i)) != 0 \u0026\u0026 dp(j, s, memo, d) == 1) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool wordBreak(string s, vector\u003cstring\u003e\u0026 wordDict) {\n\tset\u003cstring\u003e d;\n\tfor (auto x : wordDict) d.insert(x);\n\tvector\u003cint\u003e memo(s.size() + 1, -1);\n\tmemo[s.size()] = 1;\n\n\tint ans = dp(0, s, memo, d);\n\treturn ans;\n}\n```\n\n## References\n1. https://leetcode.com/problems/word-break/\n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-23\ntags: [[Programming question]], [[Leetcode]], [[Dynamic programming]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Divide-and-conquer":{"title":"Divide and conquer","content":"# Divide and conquer\nDividing problems which scale worse than linearly in proportion to input problems s.t. the sub problems we solve are smaller and then use an efficient merge routine to combine subproblems. \n- this allows us to avoid performing the main problem computation on large input\n\n\nExamples:\n- [[Closest two points in 2D]]\n- [[Karatsuba multiplication]]\n- [[Multiplying matrices]]\n- [[Convex hull problem]]\n\nThere is a common theme with multiplication of large integers and matrices.\n- divide up the problem and try to eliminate one (or more) of the required sub problems\n- for example in the addition we removed the requirement to calculate one of the multiplications bringing down the exponent from 2 to $\\log_2{3}$\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-21\ntags: [Algorithms - CS 341](Zettelkasten/Algorithms%20-%20CS%20341.md), [Algorithms](Algorithms)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Dynamic-programming":{"title":"Dynamic programming ","content":"# Dynamic programming\n\n## Name meaning\nDynamic programming is named because some guy wanted to hide the fact he was working on some research\n- it was chosen as a cool name, it has no real reason to be called dp\n\n[[Recursive algorithm | Recrusive algorithm design]]\n\n## DP concept\nDP is recursion with memoization\n- recursively solving problems only once by saving repeats\n\nDP can be sometimes seen as a local brute force method where we are checking all possible options locally, to get the best answer globally \n- this works when local options aren't impacted by options down the line\n- example: [[Bowling problem]]\n\n## Constructing optimal binary search trees\nO(n^3) -\u003e we try each root k and then we have a table DP\\[n, n\\] which has the optimal subtree cost for binary tree containing elements i..j \n\n## References\n1. mit lectures: https://www.youtube.com/watch?v=OQ5jsbhAv_M\u0026t=158s\n2. new mit lectures: https://www.youtube.com/watch?v=r4-cftqTcdI\n---\nstatus: #üå± #\ndate: 2021-11-14\ntags: [[Algorithms]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/EndeavourOS-install-and-setup":{"title":"EndeavourOS install and setup","content":"# EndeavourOS install and setup\n\n## Programs to install \n- neovim\n- obsidian md \n- spotify \n- brave \n- kitty\n- google chrome\n- flameshot\n\n## Install steps \n### Generate ssh keys\n```\nssh-keygen -t ed25519 -C \"yhosnysa@uwaterloo.ca\"\nssh-keyscan -t rsa github.com \u003e\u003e ~/.ssh/known_hosts\n```\n- add the key to github\n- https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account\n\n### Install yay\n```\nsudo pacman -S yay\n```\n\n### Install kitty\n```\nyay -S kitty\n```\n\n### Install fish\n```\nsudo pacman -S fish\n```\n\n### Install neovim\n```\nsudo pacman -S neovim\ncd ~/.config\n# comment out theme lines from init.lua\ngit clone --depth 1 https://github.com/wbthomason/packer.nvim\\\n ~/.local/share/nvim/site/pack/packer/start/packer.nvim\n# open neovim packer install, packer compile\n```\n\n### Install obsidian md\n```\nyay -S obsidian\ncd ~\ngit clone git@github.com:Hozny/everything.git\n```\n- This process can be made better with config improvements\n\n### Install emoji fonts\n\n### Install spotify\n```\nyay -S spotify\n```\n\n### Install chrome\n```\nyay -S google-chrome\n```\n\n### Install discord\n```\nyay -S discord\n```\n\n### Install flameshot\n```\nsudo pacman -S flameshot\n```\n\n## Install Go programming language\n```\nsudo pacman -S flameshot\n```\n\n## References\n1. \n\n---\nstatus: #üü¶\ndate: 2021-12-30\ntags: [Linux setup](Linux%20setup.md), [Linux](Linux), [[Tutorial]], ","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/FHL-calf-raise":{"title":"FHL calf raise","content":"# FHL calf raise\n\n## Technique\n1. Hands against wall feet out behind you to the point where calfs are slightly raised off floor. Feet further back makes it harder.\n2. Raise until weight is all on big toe.\n3. Feet further back is harder, one leg at a time is even harder.\n\n![](Zettelkasten/Pasted%20image%2020220818112859.png)\n## Why\nFlexor Hallucis Longus absorbs impact when landing so strengthening it decreases the absorption required by your knees. It is the first muscle that absorbs when you land on your foot.\n\nThe FHL calf raise ensures the weight is on your big toe more than a regular calf raise and stretches the ankle more. Ankle mobility is very important for knee health.\n### References\n1. \n\n---\nstatus: #üå±             \ndate: 2022-08-18           \ntags: [Knee ability zero](Knee%20ability%20zero.md)           ","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Floating-point-numbers":{"title":"Floating point numbers","content":"# Floating point numbers\nAny floating point number representation can only represnt a **finite** set of numbers. So for arbitrary real number x we must approximate it.\n\nWorking with floating points introduces a lot of approximations (errors). See the [[IEEE standard]] to see a way we are able to ensure the approximations are identical across machines (important for [[Portability]])\n\n## Representation\n[[Normalized form]] of floating points\n\nFloating point number representation limits\n1. Density: the number of digits, m, in the expansion\n2. Range: number of integers for p, $L \\leq p \\leq U$\n\nFloating point number system is represented by 4 parameters $F(\\beta, m, L, U)$\nWhere each number is\n$$\\pm 0.d_1d_2d_3\\cdots d_i \\times \\beta^p$$\n- each $d_i \u003c \\beta$ \n- $d_1$ is non-zero\n- there are at most m digits ($i \u003c m$)\n- $L \\leq p \\leq U$\n\nZero is given by all digits 0 and exponent zero\n\n### Dealing with limitations\nTwo ways of dealing with floating point density (digits) limitations\n- we chop a number (truncate the number of digits)\n- we round a number (if the exceeding digits is \u003e 0.5\\*Base we round up, else chop)\n\nRange limitations in IEEE\n- underflow -\u003e 0\n- overflow -\u003e $\\infty$\n- $\\frac{0}{0}$ -\u003e NaN (not a number)\n\n## Measuring floating point approximation\nGiven a real number x and our approximation y\n\n- Absolute error: |x - y|\n- Relative error: |x - y| / | x |\n\t- if x is close to 0 we modify it to |x - y| / |y| \n\nif the relative error is approximately $10^{-s}$ then we say y approximates *s significant digits*\n- if $0.5 \\times 10^{-s} \\leq \\frac{|x-y|}{|x|} \\leq 5 \\times 10^s$\n\n## Error bounds\nThe relative error is bounded for all numbers in the exponent range.\n- the max relative error is called **machine epsilon** $\\epsilon_{mach}$\nso \n$$\\frac{fl(x) - x}{x} = \\delta \\text{ where } |\\delta| \\leq \\epsilon$$\n- rewriting this gives $x = fl(x) \\cdot (1 + \\delta)$\n\n**Definition:** $\\epsilon_{mach}$ is the smallest number s.t. $fl(1+\\epsilon) \u003e 1$\n\nFor a FP system\n- $e_{mach} = \\beta^{1 - m}$ if chopping\n- $e_{mach} = 0.5 \\cdot \\beta^{1 - m}$ if rounding\n\n## Distribution of floating point numbers\nDistribution is not uniform across all numbers. Since relative error scales to the number and is bounded then for smaller numbers there must be more precision (less spacing) between numbers and for larger numbers there is more spacing (since the relative error would be the same for a larger denominator)\n- spacing $\\approx \\epsilon \\cdot |x| \\cdot 2$\n- so larger magnitude floating point numbers are more spaced apart than numbers close to 0\n\nGenerally for larger numbers we don't need the same precision as we do for smaller numbers.\n- F(10, 1, -10, 10) for example, there around 10 numbers between 0 and 1 but then it becomes integers only 2,3,4...\n- between 0 and 1 they are 0.1 apart, 1-10 they are 1 apart, 10-100 they are 10 apart\n\n## Floating point arithmetic\nWe denote floating point addition fl( fl(x) + fl(y) ) for any real x, y as $x \\oplus y$\n- this is commutative\n- this is not associative $x \\oplus (y \\oplus z) \\neq (x \\oplus y) \\oplus z$\n\nCase 1: same sign 2 floating numbers is approximately $2 \\cdot \\epsilon_{mach} \\cdot \\frac{|x| + |y|}{|x + y|}$\nCase 2: opposite signs can have large relative error since $|x + y| \u003c\u003c |x| + |y|$ if two large numbers with opposite signs\n- **caution** when subtracting large numbers\n\n## Floating point pitfalls\nThere are two main sources of error:\n1. the FP representation of the numbers themselves\n2. the arithmetic operations we perform introduce their own errors as well\n\n\n## References\n1. Lecture 1 cs 370\n2. https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html\n\t- really good document on FP systems \n3. \n\n---\nstatus:\ndate: 2022-01-07\ntags: [Numerical Computation - CS 370](Numerical%20Computation%20-%20CS%20370.md), [Programming](Programming)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Gaussian-distribution":{"title":"Gaussian distribution","content":"# Gaussian distribution\nIf we assume a Guassian data fora  given data then\n1. sample mean and median should be close\n2. skewness close to 0 and kurtosis close 3\n3. 95% of observations lie within 2 standard deviations of the mean\n\nIf any one of these fails by a large degree then it is usually sufficient to warrant concerns (does not follow gaussian)\n\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-11\ntags: [Statistics 241](Statistics%20241.md), [Statistics](Statistics)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Git-submodule":{"title":"Git submodule","content":"# Git submodule\n```\ngit submodule add -b \u003cbranch\u003e \u003curl\u003e \u003crelative_path_4m_root\u003e\n\ngit submodule add \u003curl\u003e \u003crelative path\u003e\n```\n## References\n1. \n\n---\nstatus: #üîµ\ndate: 2021-12-31\ntags: [[Tutorial]], [[Git]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Graph-algorithms":{"title":"Graph algorithms","content":"# Graph algorithms\nn typically represents number of vertices (nodes). m is number of edges.\n\n\n## Notations\n- degree(v) : for undirected graphs - number of edges with v\n- indegree(v) : how many point into the vertex\n- outdegree(v) : how many point out the vertex\n\n## Definitions\n- **path:** a sequence of vertices connected by edges\n- **cycle:** a path that starts and endgs with the same vertex\n- **simple cycle:** a cycle with no repeated vertices\n- **tree:** a connected undirected graph without cycles\n- **connected:** undirected graph if every vertex is joined by a path\n- **connected component:** maximal connected subgraph\n\n## Storing graphs\n- Adjacency matrix: A\\[i, j] = 1 if (i, j) exists\n\t- O(n^2) space\n- Adjacency list: linked list for each vertex's neighbours\n\t- O(n + m) space\n\t\n![[Pasted image 20220302220547.png]]\n\n## Traversal algorithms\nbfs\n- use a queue and explore by level\n- mark discovered vertices\n- the level of a vertex v in bfs is the minimum distance from v_0 to v\n- if we encounter an edge to an already visited node the graph has a cycle\ndfs\n- explore children\n\n## Test bipartite\nrun BFS and save V1 = even levels, V2 = odd levels\n- for any edge connected u, v we need u, v to be not in the same V1 or V2\n\nif **not** bipartite then there is an odd cycle\n- bipartite iff no odd cycle is a theorem\n\n## Minimum spanning trees\nKruskal's algorithm\n- add minimum edge greedily - never introduce a cycle\n\n[[Prim's algorithm]]\n\n## Shortest path in unweighted graphs\nBFS in unweighted graph finds the minimum path, since it finds least number of edges from S to T.\n\n## Shortest path in weighted graphs\n### Djikstra's algorithm O(m log n)\nidea: grow a tree from the starting vertex\n\nalgorithm: Greedily pick the closest vertex that is not visited by the tree\n- **note:** Djikstra's algorithm requires no negative weights\n![[Pasted image 20220315125629.png]]\n\n### Shortest path in DAG O(m + n)\nToplogical sort so that every vertex doesn't point to any vertex before it\n\nGo through the vertices from 1 .. n and calculate the minimum distance to that vertex\n![[Pasted image 20220315130624.png]]\n\n### Bellman-Ford single source (no negative cycle) O(n \\* (n + m))\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-03-02\ntags: [[Algorithms]], [[Algorithms - CS 341]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Graphical-data-summaries":{"title":"Graphical data summaries","content":"# Graphical data summaries\n\n[[Histograms]]\n[[Commulative distribution function]]\n[[Boxplots]]\n[[Run chart]]\n[[Pie charts are bad]]\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-13\ntags: [Statistics 241](Statistics%20241.md), [Statistics](Statistics)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Greedy-algorithms":{"title":"Greedy","content":"# Greedy algorithms\n\nExamples:\n- [[Minimum number of coins to make change]]\n- [[Maximum number of non-overlapping intervals]]\n\n## Proving greedy algorithms\nThere are two general techniques that could be used\n1. show that the greedy solution stays ahead (optimal) all the time\n2. \"exchange\" proof \n\t1. get an optimal solution and show you can swap it around and arrive at greedy solution maintaining optimality\n\n\t\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-28\ntags: [[Algorithms]], [[Algorithms - CS 341]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Histograms":{"title":"Histograms","content":"# Histograms\n\nBasic idea is to create a graphical summary that is comparable with a [Probability density function](Probability%20density%20function.md)].\n\n![](Zettelkasten/Pasted%20image%2020220113101551.png)\n- the area of the bars should match the frequency (width=1 -\u003e height=freq)\n- usually intervals of equal width\n\nRelative frequency histogram\n![](Zettelkasten/Pasted%20image%2020220113101902.png)\n- the total area here will sum to 1\n- we divide the height of a regular histogram by the sample size\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-13\ntags: [Statistics](Statistics)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Home":{"title":"Home","content":"# Home\n[[University]]\n[[Personal performance]]\n\n## Entertainment\n[[TV Shows List]]\n[[Reading list]]\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-05-01\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/House-robber":{"title":"House robber ","content":"# House robber\nProblem: \n\nSolution:\n\nImplementation:\n```c++\nint dp(int i, vector\u003cint\u003e \u0026memo, vector\u003cint\u003e \u0026nums) {\n\tif (i \u003e= nums.size()) return 0;\n\n\tint\u0026 ret = memo[i];\n\tif (ret != -1) return ret;\n\n\tret = max(nums[i] + dp(i+2, memo, nums), dp(i+1, memo, nums));\n\treturn ret;\n}\n\nint rob(vector\u003cint\u003e\u0026 nums) {\n\t// subproblem: dp[i] = max profit of suffix starting at\n\t// relation:   dp[i] = max(a[i] + dp[i+2], dp[i+1])\n\t// topology:   smaller i depends on larger i\n\t// base case:  dp[n] = 0\n\t// problem:    dp[0] \n\tvector\u003cint\u003e memo(nums.size()+1, -1);\n\treturn dp(0, memo, nums);\n}\n```\n## References\n1. https://leetcode.com/problems/house-robber/submissions/\n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-24\ntags: [[Programming question]], [[Leetcode]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/House-robber-ii":{"title":"House robber ii ","content":"# House robber ii\nProblem:\n\nSolution:\n- handle case at i == 0, send use two different memos\nImplementation:\n```c++\nint dp(int i, int e, vector\u003cint\u003e \u0026memo, vector\u003cint\u003e \u0026memo2, vector\u003cint\u003e \u0026nums) {\n\tif (i \u003e= e) return 0;\n\n\tint \u0026ret = memo[i];\n\tif (ret != -1) return ret;\n\n\tif (i == 0) {\n\tret = max(nums[i] + dp(i+2, nums.size() - 1, memo2, memo2, nums), dp(i+1, nums.size(), memo, memo, nums));\n\t} else { \n\tret = max(nums[i] + dp(i+2, e, memo, memo, nums), dp(i+1, e, memo, memo, nums));\n\t}\n\n\treturn ret;\n}\nint rob(vector\u003cint\u003e\u0026 nums) {\n\tvector\u003cint\u003e memo(nums.size() + 1, -1);\n\tvector\u003cint\u003e memo2(nums.size() + 1, -1);\n\treturn dp(0, 2, memo, memo2, nums);\n}\n```\n## References\n1. \n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-24\ntags: [[Programming question]], [[Leetcode]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/IEEE-standard":{"title":"IEEE standard","content":"# IEEE standard\n\n## References\n1.  https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html\n\n---\nstatus:\ndate: 2022-01-10\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Insert-intervals":{"title":"Insert intervals ","content":"# Insert intervals\nQuestion: \n- given list of sorted non-overlapping intervals, insert an interval\n\nSolution:\n- insert to the end of the list and run the same code for [[Merge intervals]]\n\n```\nintervals.push_back(newInterval);\n        \nsort(intervals.begin(), intervals.end());\nvector\u003cvector\u003cint\u003e\u003e ret;\nint c = -1;\nfor (auto i : intervals) {\n\tif (c != -1 \u0026\u0026 i[0] \u003c= ret[c][1]) {\n\t\tret[c][1] = max(ret[c][1], i[1]);\n\t} else {\n\t\tret.push_back(i);\n\t\t++c;               \n\t}\n}\nreturn ret;\n```\n\n## References\n1. \n\n---\nstatus:\ndate: 2021-11-11\ntags: [[Leetcode]], [[Merge intervals]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Internalizing-ideas":{"title":"Internalizing ideas ","content":"# Internalizing ideas\nThere is a difference between understanding a principle and internalizing it.\n- This relates to all ideas but is very apparent with behavioural concepts\n\n## References\n1. \n\n---\nstatus: #üå±  #üü© \ndate: 2021-11-28\ntags: [[]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Interpolation":{"title":"Interpolation","content":"# Interpolation\nInterpolate (guess a function) for a list of (x, y) pairs.\n- focus of application in cs370 is on interpolations applicability to computer graphics\n\n## Polynomial interpolation\nTheorem: Given n data pairs (xi , yi), i = 1, . . . , n with distinct xi, there is a unique polynomial p(x) of degree not exceeding n ‚àí 1 that interpolates this data.\n- *unisolvence theorem*\n\n![[Pasted image 20220316093018.png]]\n\n### Lagrange form\n![[Pasted image 20220316093201.png]]\n- this allows us to interpolate without solving the vadnermonde system\n\n### Piecewise Hermite interpolation\nIf we want to interpolate a function and its derivative at vertain points we can set up the equations again to solve them uniquely.\n![[Pasted image 20220316093750.png]]\n- piecewise cubic for each interval\n\n![[Pasted image 20220316093844.png]]\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-03-16\ntags: [[Programming]], [[Numerical Computation - CS 370]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Jiu-jitsu":{"title":"Jiu jitsu","content":"\n# Jiu jitsu\nNeed to make a training plan/goals for BJJ.\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-03-19\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Job-interview-tracking":{"title":"Job interview tracking","content":"# Job interview tracking\n\nTracking job interviews I've had.\n\n## 2022\n- ‚ùå Akuna C++ Intern , (find a valley, implement std::vector) \n\t- I could have passed this if I put a little more effort in.\n- ‚úÖ SingleStore Intern, 3 rounds (memcache, bfs link a tree, 4sum) \n\n## 2021\n- ‚úÖ Demonware, 1 round (print a matrix, c++/python trivia, failed db trivia)\n\n## 2018\n- ‚ùå SunnyBrook Hospital high school research\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-08-12\ntags: [[Career]],","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Jump-game":{"title":"Jump game ","content":"# Jump game\nProblem: a[i] is how far u can jump, can you reach the end of the list\n\nSolution:\n- Notice the limiting factor is when a[i] == 0.\n- Need to make sure that we can jump over any 0\n- Keep track of max jump we could have made and if a[i] == 0 check that we can go over it\n\nImplementation:\n```c++\nclass Solution {\npublic:\n    bool canJump(vector\u003cint\u003e\u0026 nums) {\n        int p = 0;\n        for (int i = 0; i \u003c nums.size(); ++i) {\n            if (nums[i] == 0 \u0026\u0026 p \u003c= i \u0026\u0026 i != nums.size() - 1) {\n                return false;\n            }\n            p = max(p, i + nums[i]);\n        }\n        return true;\n    }\n};\n```\n## References\n1. \n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-13\ntags: [[Programming question]], [[Leetcode]], [[Greedy algorithms]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Karatsuba-multiplication":{"title":"Karatsuba multiplication","content":"# Karatsuba multiplication\n![](Assets/Pasted%20image%2020220122163717.png)\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-22\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Kinematic-equations":{"title":"Kinematic equations","content":"# Kinematic equations\nAssuming constant acceleration (const a)\n1. $v = v_0 + a \\cdot t$\n2. $\\Delta x = v_0 \\cdot t + \\frac{1}{2} \\cdot a \\cdot t^2$\n3. $v^2 = v_0^2 + 2 a \\Delta x$\n4. $\\bar{v}t = \\Delta x$\n\t- $\\Delta x = \\frac{v_0 + v}{2} \\cdot t$\n\n\t\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-08\ntags: [Physics 1 - Phys 111](Physics%201%20-%20Phys%20111.md), [[Physics]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Knee-ability-zero":{"title":"Knee ability zero","content":"# Knee ability zero\n\nStart with the first two exercises and add the next exercise when you meet the goals of the exercises you are doing.\n\n[[Tibialis raise]] \n- 25 reps, hold 2 seconds at the top\n- move feet further from wall to increase difficulty      \n- Goal: 25 reps with feet far away\n\n[[FHL calf raise]]\n- 25 reps, right after tibialis raise\n- Goal: 25 reps with one leg\n\n[[Knees over toes calf raise]]\n- Prerequisite: meet the goal for the exercises above\n- 25 reps\n- Goal: 25 reps with one leg\n\n[[Patric step]]\n- Prerequisite: meet the goal for the exercise above\n- 25 reps\n- Goal: 25 full ankle range\n\n[[Ass to grass split squat]]\n- Prerequisite: meet the goal for the exercise above\n- 5 reps each side, take 30 seconds break in between if needed\n\n[[Sissy squat]]\n- this exercise is not required, only if looking for athletic performance\n\n### TODO:\nI will add accessory movements later\n### References\n1. Knee ability zero by \n\n---\nstatus: #üå± \ndate: 2022-08-18\ntags: [[Gym workout routine]], [[Health]], [[Personal performance]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Knees-over-toes-calf-raise":{"title":"Knees over toes calf raise","content":"# Knees over toes calf raise\n\n## Technique\n1. Stand about arms length away from wall\n2. Bend knees over toes to a comfortable level. Ideally ankles should lift off floor slightly\n3. Lift your calves like a calf raise\n4. Once it is easy to do 25 reps with knee bend and ankle lifting off floor, switch to single leg for harder variation\n\n![](Zettelkasten/Pasted%20image%2020220818112830.png)\n\n## Why\nTwo parts of the calves, gastroc and soleus. Soleus is worked more in a bent knee calf raise than standing calf raise. \n\nSeated calf raises are also good because the knee is bent.\n\n### References\n1. \n\n---\nstatus: #üå±             \ndate: 2022-08-18           \ntags: [Knee ability zero](Knee%20ability%20zero.md)           ","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/LLVM":{"title":"LLVM","content":"# LLVM\nA set of tools / a library for developing compilers\n- provides front-end and back-end tools to compile down to different machines\n\nAn abstraction to allow for creation of compiler-like functionality.\n## References\n1. https://stackoverflow.com/questions/2354725/what-exactly-is-llvm\n\n---\nstatus: #üìö #üü©\ndate: 2021-11-14\ntags: [[Compilers]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Leetcode":{"title":"Leetcode","content":"# Leetcode\n\nMeta note for solutions to link to.\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-08-12\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Level-order-traversal":{"title":"Level order traversal ","content":"# Level order traversal\nProblem:\n- return level order values of a binary tree\n\nSolution:\n- bfs and save each level in a vector\n\nImplementation:\n```c++\n\tvector\u003cvector\u003cint\u003e\u003e lo;    \n\tqueue\u003cTreeNode*\u003e q;\n\tq.push(root);\n\twhile (q.size() \u003e 0) {\n\t\tint s = q.size();\n\t\tvector\u003cint\u003e temp;\n\t\tfor (int i = 0; i \u003c s; ++i) {\n\t\t   TreeNode* cur = q.front(); \n\t\t   q.pop(); \n\t\t   if (cur != nullptr) {\n\t\t\t   temp.push_back(cur-\u003eval);\n\t\t\t   q.push(cur-\u003eleft);\n\t\t\t   q.push(cur-\u003eright);\n\t\t   }\n\t\t}\n\t\tif (temp.size() \u003e 0)\n\t\t\tlo.push_back(temp);\n\t}\n\treturn lo;\n```\n## References\n1. https://leetcode.com/problems/binary-tree-level-order-traversal\n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-28\ntags: [[Programming question]], [[Leetcode]], [[Leetcode medium]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Likelihood-function-for-independent-experiments":{"title":"Likelihood function for independent experiments","content":"# Likelihood function for independent experiments\n\nIf we assume the experiments are independent then $P(A \\cap B) = P(A)\\cdot P(B)$\n\nSo we multiply their likelihood functions and maximize that to maximize their combined probability.\n\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-20\ntags: [Statistics](Statistics), [Statistics 241](Zettelkasten/Statistics%20241.md)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Limited-direct-execution":{"title":"Limited direct execution","content":"# Limited direct execution\nThe idea is to let processes run directly on the CPU with *limitations*\n- in user mode a process cannot access certain instructions / IO\n\nThe OS will start the [Process creation](Zettelkasten/Process%20creation.md). Then once the process is done the OS takes control back and frees memory.\n\nTo execute priviledged commands the process must call a [[System call]] which is a synchronous call to the kernel to execude specific priviledged instructions.\n- The **system call handler** will use the **trap table** to invoke the specific OS (kernel) code it should run\n- The user process leaves a code somewhere then traps into the kernel where the **trap handler** will handle based on the code provided\n\t- this allows user code to indirectly define what code it wants to run then the kernel performs additional checks\n- see also [Operating system trap](Zettelkasten/Operating%20system%20trap.md) to elevate into kernel mode\n\nCPU has a mode bit (*Dual mode execution system*)\n- assuming it is 1 bit is a simplification there is more to it than 1 bit\n- this allows some instructions to be executed in **user mode**\n- some instructions are only allowed in **priviledged mode**\n\n## Steps for LDE protocol\nOn boot\n- initialize trap table and CPU remembers location for later\nRunning a process\n- OS sets up a few things (allocate memory, create node on process list, ..., [Process creation](Zettelkasten/Process%20creation.md))\n- Process runs\n- Process calls [System call](System%20call) which [Operating system trap](Zettelkasten/Operating%20system%20trap.md) into the OS\n- OS returns from trap\n- Process completes\n- OS cleans up process\n\n## OS taking control when a process is running\nThe OS uses an [[Operating system timer]] which calls an interrupt every x amount of time forcing the OS to take control.\n- notice the timer triggers *hardware* to save some registers, then context switching saves register using *software*\n\nAfter the interrupt gives OS control again the [Operating system scheduler](Zettelkasten/Operating%20system%20scheduler.md) decides whether or not to perform a [Context switch](Zettelkasten/Context%20switch.md) to a different process.\n\n## LDE flow\n![](Assets/Pasted%20image%2020220126164122.png)\n### References\n1. kk\n\n---\nstatus: #üå± \ndate: 2022-01-26\ntags: [Processes](Zettelkasten/Processes.md), [Operating System](Zettelkasten/Operating%20System.md), [Operating Systems - CS 350](Zettelkasten/Operating%20Systems%20-%20CS%20350.md)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Linux-setup":{"title":"Linux setup","content":"# Linux setup\n\n## Distro\n- Endeavour OS ([[EndeavourOS install and setup]])\n\t- arch linux without having to deal with install process\n\t\n## Window manager\n- DWM \n\t- simple, minimal and already effective\n\t- probably use Luke Smith's dwm build\n- i3\n\t- more resources for using it \n\t- official documentation here: https://discovery.endeavouros.com/installation/i3-wm/2021/03/\n\t- I think it is easier to install i3 alongside KDE as opposed to DWM (not sure about this didn't do much research)\n\t\n## References\n1. https://www.youtube.com/watch?v=gGeA7QQIfp4 (rando video on endeavouros)\n2. https://discovery.endeavouros.com/installation/i3-wm/2021/03/ (i3 endeavouros)\n\n---\nstatus: #üå± \ndate: 2021-12-28\ntags:  [[EndeavourOS install and setup]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Lock-based-data-structures":{"title":"Lock-based data structures","content":"# Lock-based data structures\nData structures that with locks to enable concurrent use of them.\n\n## Counters\nWe have concurrent counters with locks. These are trivial.\n\nWe can have approximate counters which increase paralleilzation performance. We can vary the approximation factor to change performance / accuracy.\n\n## Linked lists\nHand-over-hand locking is when each node has its own lock and when we traverse it we grab and release as we go.\n- performance is an issue with this. Maybe grab every *n* nodes\n\n## Queue\nWe add a lock for the head and tail to separate the enqueue and dequeue operations.\n\n### References\n1. `www.cs.tau.ac.il/ ÃÉshanir/concurrent-data-structures.pdf` (reference with more info - \"Concurrent Data Structures‚Äù by Mark Moir and Nir Shavit.\")\n2. https://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks-usage.pdf\n\n---\nstatus: #üå± \ndate: 2022-02-28\ntags: [[Operating System]], [[Thread locks]], [[Concurrency]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Longest-Increasing-Subsequence":{"title":"Longest Increasing Subsequence ","content":"# Longest Increasing Subsequence\nProblem:  Find the longest increasing subsequence\n\nThis can be reduced to [[Longest common subsequence]] by matching sequence against its sorted version still O(n^2)\n\n## Quadratic solution\nSolution:\n- O(n^2) solution is dp with subproblem: dp[i] is the longest increasing subsequence of suffix starting at i\n```\n// subproblem: l(i) = longest increasing subsequence starting at i (includes i)\n// relation:   l(i) = 1 + l(j) if (j \u003e i, a[j] \u003e a[i], j \u003c n)\n// topology:   descending i (smaller i depends on j)\n// base case:  l(n) = 0\n// original:   l(0)\n```\n\nImplementation:\n```c++\nint lis(int i, vector\u003cint\u003e \u0026memo, vector\u003cint\u003e \u0026nums) {\n\tif (i \u003e= nums.size()) return 0;\n\n\tint\u0026 ret = memo[i];\n\tif (ret != -1) return ret;\n\n\tret = 1;\n\tfor (int j = i + 1; j \u003c nums.size(); ++j)\n\t\tif (nums[j] \u003e nums[i]) ret = max(ret, 1 + lis(j, memo, nums));\n\n\treturn ret;\n}\n\nint lengthOfLIS(vector\u003cint\u003e\u0026 nums) {\n\t// subproblem: l(i) = longest increasing subsequence starting at i (includes i)\n\t// relation:   l(i) = 1 + l(j) if (j \u003e i, a[j] \u003e a[i], j \u003c n)\n\t// topology:   descending i (smaller i depends on j)\n\t// base case:  l(n) = 0\n\t// original:   l(0)\n\tvector\u003cint\u003e memo(nums.size() + 1, -1);\n\tint ans = -1;\n\tfor (int i = 0; i \u003c nums.size(); ++i)\n\t\tans = max(ans, lis(i, memo, nums));\n\treturn ans;\n}\n```\n\n## n log n solution\nThere is a way to optimize the dp to binary search at recursive steps rather than O(n) scan\n\n## References\n1. https://leetcode.com/problems/longest-increasing-subsequence/submissions/\n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-23\ntags: [[Programming question]], [[Leetcode]], [[Dynamic programming]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Longest-common-subsequence":{"title":"Longest common subsequence ","content":"# Longest common subsequence\n\nProblem: Given two sequences find longest common subsequence\n\n## Solution\nUsing [[Recursive algorithm]]\n1. **Subproblem:** LCS of some suffix of A and some suffix of B (using indices i, j)\n\t- LCS(i, j) = LCS(A[i:], B[j:])\n2. **Relate:** \n\t- if A[i] == B[i] : 1 + L(i+1, j+1)\n\t- else: max(L(i+1, j), L(i, j+1))\n1. **Topological**  L(|A|, j) = 0 = L(i, |B|)\n2. **Base case** \n3. **Original** problem via subproblem\n\nImplementation:\n```c++\n// subproblem: lcs(i, j) = lcs of suffix t1[i:] and t2[j:]\n// relation:   lcs(i, j) = if t1[i] == t[j] -\u003e 1 + lcs(i+1, j+1)\n//                         else max(lcs(i+1, j), lcs(i, j+1))\n// topology:   small i depends on large i\n// base case:  lcs(len(t1), j) == 0 == lcs(i, len(t2))\n// original:   lcs(0, 0)\n\nint lcs(int i, int j, vector\u003cvector\u003cint\u003e\u003e \u0026memo, string\u0026 t1, string\u0026 t2) {\n\tif (i == t1.size() || j == t2.size()) return 0;\n\n\tint\u0026 ret = memo[i][j];\n\tif (ret != -1) return ret;\n\n\tif (t1[i] == t2[j]) ret = 1 + lcs(i+1, j+1, memo, t1, t2);\n\telse {\n\t\tret = max(lcs(i+1, j, memo, t1, t2), lcs(i, j+1, memo, t1, t2));\n\t}\n\n\treturn ret;\n}\nint longestCommonSubsequence(string text1, string text2) {\n\t\n\tvector\u003cvector\u003cint\u003e\u003e memo(text1.size() + 1, vector\u003cint\u003e(text2.size() + 1, -1));\n\treturn lcs(0, 0, memo, text1, text2);\n}\n```\n\n## References\n1. \n\n---\nstatus:\ndate: 2021-11-23\ntags: [[Leetcode]], [[Programming question]], [[Dynamic programming]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Markov-matrices":{"title":"Markov matrices","content":"# Markov matrices\n\nColumns add to 1. Each value represents probability.\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-02-03\ntags: [[Page rank algorithm]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Master-theorem":{"title":"Master theorem","content":"# Master theorem\n![](Assets/Pasted%20image%2020220116161559.png)\n\nRough proof idea:\n![](Assets/Pasted%20image%2020220116162804.png)\n- notice each level has a denominator of $b^k$ and coeffcient $a$\n\t- if $a \u003c b^k$ then each level is getting exponentially smaller than the previous level. And so the highest level dominates (i.e, O(n^k))\n\t- if $a \u003e b^k$ then each level is getting bigger and the last level dominates\n\n![](Assets/Pasted%20image%2020220116163225.png)\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-16\ntags: [Algorithms - CS 341](Zettelkasten/Algorithms%20-%20CS%20341.md), [Algorithms](Algorithms)KJ","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Maximum-depth-of-a-binary-tree":{"title":"Maximum depth of a binary tree ","content":"# Maximum depth of a binary tree\nProblem:\n- return maximum depth of a binary tree\n\nSolution:\n- dfs and save biggest depth\n\nImplementation:\n```c++\nint ans = 0; \nvoid dfs(TreeNode* cur, int d) { \n\tif (cur-\u003eleft) dfs(cur-\u003eleft, d+1);\n\tif (cur-\u003eright) dfs(cur-\u003eright, d+1);\n\tans = max(ans, d);\n}\nint maxDepth(TreeNode* root) {\n\tif (!root) return 0;\n\tdfs(root, 1);\n\treturn ans;\n}\n```\n## References\n1. https://leetcode.com/problems/maximum-depth-of-binary-tree/\n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-28\ntags: [[Programming question]], [[Leetcode]], [[Leetcode easy]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Maximum-likelihood-estimation":{"title":"Maximum likelihood estimation","content":"# Maximum likelihood estimation\n\nGiven some some sample data and some unknown probability $\\theta$. We find $\\theta$ s.t. maximize the probability that the given data is observed.\n\n\nThe probability of the data being observed is irrelevant since the value doesn't scale for different size samples. We only care about maximizing it's maginitute not what it's magnititude it is.\n- see [[Relative likelihood function]]\n\n\nFor continuous data we maximize on the p.d.f instead of the probability function.\n\n## Maximizing\nWe usually solve for when the derivative of $L(\\theta) = 0$ for multiple parameter functions we solve each partial equal to 0.\n\n## invariance property\nThe maximum likelihood has an [[Invariance property]] where if $\\hat{\\theta}$ is the maximum likelihood estimate of $\\theta$, then $g(\\hat{\\theta})$ is the maximum likelihood estimate of $g(\\theta)$\n\n## expected counts\nThe sum of expected counts sums to the data count when operating with maximum likelihood probabilities.\n\n## distributions\nPoisson ($\\hat{\\theta}=\\bar{y}$): should use the sample mean as $\\hat{\\theta}$\nGaussian: should use mean and standard deviation **unless** specifically asked for **maximum likelihood**\nBinomial: $\\hat{\\theta} = \\frac{y}{n}$\nExponential: $\\hat{\\theta} = \\bar{y}$\nMultinomial: $\\hat{\\theta_i} = \\frac{y_i}{n}$\n## Combnining likelihoods\nIf we have two data sets from **independent** studies then the combined likelihood function is \n$$L(\\theta) = L_1(\\theta) \\cdot L_2(\\theta)$$\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-20\ntags: [Statistics](Statistics), [Statistics 241](Zettelkasten/Statistics%20241.md)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Measure-of-central-tendancy-or-location":{"title":"Measure of central tendancy or location","content":"# Measure of central tendancy or location\n\nNumerical measures of the centre of data\n- **sample** mean, median, mode\n- do not just write mean if it is a **sample** mean\n- mean (without sample) usually refers to theoretical means of distributions i.e $\\mu$ for gaussian\n\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-11\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Measures-of-variability-or-dispersion":{"title":"Measure of variability or dispersion","content":"# Measures of variability or dispersion\n\nSample variance\n$$s^2 = \\frac{1}{n-1}\\Sigma^n_{i=1}(y_i-\\bar{y})^2 = \\cdots$$\n- notes the n-1 which is just n in the population variance\n\n\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-11\ntags: [Statistics 241](Statistics%20241.md), [Statistics](Statistics)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Merge-intervals":{"title":"Merge intervals ","content":"# Merge intervals\nQuestion: \n- given list of intervals merge them so that there is a minimum number of them\n- (combine overlapping segments)\n\n\nSolution: \n- sort list of intervals by first\n- create new list of intervals and greedily merge if interval.start \u003c= end of the last item in list being built\n- if not, insert new item to the list\n\n```c++\nsort(intervals.begin(), intervals.end());\nvector\u003cvector\u003cint\u003e\u003e ret;\nint c = -1;\nfor (auto i : intervals) {\n\tif (c != -1 \u0026\u0026 i[0] \u003c= ret[c][1]) {\n\t\tret[c][1] = max(ret[c][1], i[1]);\n\t} else {\n\t\tret.push_back(i);\n\t\t++c;               \n\t}\n}\nreturn ret;\n```\n\n## References\n1. https://leetcode.com/problems/merge-intervals/\n\n---\nstatus:\ndate: 2021-11-11\ntags: [[Leetcode]], [[Greedy algorithms]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Merge-k-sorted-lists":{"title":"Merge k-sorted lists ","content":"# Merge k-sorted lists\nproblem: given array of k linked lists in ascending order, merge them into one sorted linked-list\n\nn is number of lists, k is number of elements in lists\n\nsolution O(n * log(k)):\n- split lists into pairs\n- merge pairs using standard 2-merge\n\t- basically it's a nested 2-merge (a merge on lists as whole, and merging the lists themselves)\n\t\nBad implementation O(n * k^2)\n- use 2-merge to merge merge the first two\n- remove the second and repeat until u have merged all of them into 1\n\n## References\n1. https://leetcode.com/problems/merge-k-sorted-lists/\n\n---\nstatus: #üå± #üü¶ \ndate: 2021-11-09\ntags: [[Leetcode]], [[Programming question]], [[Programming implementation]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Method-of-moment-estimates":{"title":"Method of moment estimates","content":"# Method of moment estimates\n\n\nFor a Gaussian the method of moments estimate is the same as the [[Maximum likelihood estimation]].\n\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-27\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Minimum-window-substring":{"title":"Minimum window substring ","content":"# Minimum window substring\nProblem: Minimum substring which contains all letters of another string t\n\nSolution:\n- sliding window, iterate right till all letters are found\n- iterate left as much as possible without losing required letter else iterate right\n\nImplementation:\n```c++\n// keep track of kjk\nmap\u003cchar, int\u003e m, m2;\nfor (auto c : t) m[c]++;\n\nint count = 0; int l = 0; int r = 0;\nint ans = INT_MAX;\nint al = -1;\nwhile (r \u003c s.size()) {\n\tif (m.count(s[r]) != 0 \u0026\u0026 m2[s[r]] \u003c m[s[r]]) count++;\n\tm2[s[r]]++;\n\twhile (l \u003c r \u0026\u0026 m2[s[l]] \u003e m[s[l]]) { \n\t\tif (m[s[l]] \u003e 0) m2[s[l]]--;\n\t\tl++; \n\t}\n\tif (count \u003e= t.size()) {\n\t\tif (r - l + 1 \u003c ans) {\n\t\t\tans = r - l + 1;\n\t\t\tal = l;\n\t\t}\n\t}\n\tcout \u003c\u003c l \u003c\u003c \" \" \u003c\u003c r  \u003c\u003c \" \" \u003c\u003c count \u003c\u003c endl;\n\tr++;\n}\nif (ans == INT_MAX) return \"\";\nreturn s.substr(al, ans);\n```\n\n## References\n1. \n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-27\ntags: [[Programming question]], [[Leetcode]]\n","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Models-of-computation":{"title":"Models of computation","content":"# Models of computation\n\n## Random Access Machine (RAM) model\n- \"random access\" means we access memory location *i* in 1 time step \n\nWe need to account for \"size\" of a memory location \n- good compromise: word RAM\n\t- each location holds on word\n\t- assume number of bits in word is $\\Theta(\\log{n}), n = \\text{input size}$\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-14\ntags: [Algorithms](Algorithms), [Algorithms - CS 341](Zettelkasten/Algorithms%20-%20CS%20341.md), [Programming](Programming)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Multiprogramming-process-states":{"title":"Multiprogramming process states","content":"# Multiprogramming process states\n![](Zettelkasten/Pasted%20image%2020220112150046.png)\n- notice a *ready* process can only go *running* from *ready*\n- notice a *waiting* process can only go *ready* (it must wait to be scheduled can't just resume once unblocked)\n\nWaiting is sometimes called the **blocked** state \n\nThere is a **zombie** (unix-based term) for states that are stopped but not cleaned up\n- e.g use is a parent process checking return code of a child process\n\n[[Zettelkasten/Operating system scheduler]]\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-12\ntags: [Operating Systems - CS 350](Operating%20Systems%20-%20CS%20350.md), [Operating System](Operating%20System.md)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/NP-and-NP-Complete":{"title":"NP and NP-Complete","content":"# NP and NP-Complete\n\n## Non-deterministic polynomial time\n- Decision problem \n- If the answer is yes we can check it is correct in polynomial time\n\n## NP-complete\nNP problems that are poly-reducable to each other.\n\n[[SAT problem]]\n- 3 SAT is also NP-complete\n\n[[Proof that travelling salesman problem can't be approximated]]\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-04-04\ntags: [[Algorithms]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Normalized-form":{"title":"Normalized form","content":"# Normalized form\n$$0.d_1d_2d_3\\cdots \\times \\beta^p$$\n123.4 -\u003e $0.1234 \\cdot 10^3$\n- 1234 is the mantissa\n- 3 the exponent\n- 10 is the base\n\nFirst digit after the decimal must be non-zero\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-07\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Numerical-Computation-CS-370":{"title":"Numerical Computation - CS 370","content":"# Numerical Computation - CS 370\n## Grading\n- 5 assignments = 70% (first one is 10% rest are 15%)\n- midterm 10%\n- final 20%\n\nBest mark of final used for 30% if higher than midterm\n\n## Content\n[[Floating point numbers]]\n[[Numerical linear algebra]]\n- [[Page rank algorithm]]\nDifferential equations\n[[Interpolation]]\nFourier transforms\nLeast squares\n\n## Schedule\nTENTATIVE COURSE SCHEDULE  \nFloating Point Numbers: 1 week\nLinear Algebra: 2 weeks\nDifferential Equations 2.5 weeks\nInterpolation: 1.5 weeks\nFourier Transforms: 2 weeks\nLeast Squares: 1 week\n\nOther important dates (approximate):\nJan 21: A1 due\nFeb 4: A2 due\nFeb 18: A3 due\nFeb 19-27: Reading Break (no classes)  \nMar 4: Midterm due\nMar 18: A4 due \nApr 1: A5 due\n## References\n1. https://learn.uwaterloo.ca/d2l/le/content/761310/viewContent/4211829/View\n\n---\nstatus: \ndate: 2022-01-06\ntags: [[Zettelkasten/Course outline]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Numerical-linear-algebra":{"title":"Linear algebra","content":"# Linear algebra\nSolving systems of equations using [[Gaussian elimination]]\n\n\n![](Assets/Pasted%20image%2020220123215417.png)\n- so [Gaussian elimination](Gaussian%20elimination) factors A into product of upper and lower unit diagonal matrices\n- if you save the multipliers in the lower triangular part of the matrix when performing Gaussian elimination you end up with L (A = LU factorization)\n\nSolving linear systems computationally we perform A = LU factorization then use forward and back solves\n- this allows for cheaper recomputation using different x in Ax = b\n- cheaper computing $A^{-1}$ (note it is 4 times more expensive to find Ax = b using the inverse)\n\n## LRU stability\nWe can have numbers approach 0 because and then because of roundoff errors \n\n## Partial pivoting\nThis allows us to decrease roundoff errors in [[Gaussian elimination]] with increased stability.\n![[Pasted image 20220131202904.png]]\n- This is basically a generalization of stander GE theorem (P would b identity in normal case)\n\n## NLA conditioning\nMeasuring the maximum potential accuracy\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-23\ntags: [Numerical Computation - CS 370](Zettelkasten/Numerical%20Computation%20-%20CS%20370.md), ","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Operating-System":{"title":"Operating System","content":"# Operating System\nAn operating system is an abstraction of physical resources.\n- resource manager, virtual machine (virtualizes the physical hardware)\n\n## Three pieces of an OS\n[[Virtualization]]\n- [[Processes]], [[Virtual memory]]\n- two identical programs can point to the same \"address\" in memory because the OS virtualizes their **virtual address space**\n- they each see their own scope of memory (a process thinks it sees the entire memory)\n\n[[Concurrency]]\n- [[Threads]] are like multiple functions running within the same memory space\n\n[[Persistance]]\n- the [[File system]] is the part of the OS that manages the persistant files on a computer\n\n\n## Security\nOperating system is in **supervisor mode**, user is in **unpriviledged mode**. User makes request to OS which then touches resources and responds.\n![](Zettelkasten/Pasted%20image%2020220106121823.png)\n\nOperating systems need [[Operating system multitasking \\| multitatsking]]\n\nApplication vs. Process\n- a process is somethingly actively running (processed) by the cpu\n\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-06\ntags: [Operating systems - CS 350](Operating%20systems%20-%20CS%20350.md), ","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Operating-Systems-CS-350":{"title":"Operating Systems - CS 350","content":"# Operating Systems - CS 350\n\n## Grading\n- quizes (5%), assignments (60%), midterm (15%), final (20%)\n\n[[Adress spaces]]\n## Content\n\t- [[Multiprogramming process states]], [[Process control block]], [[Zettelkasten/Context switch]], [[Zettelkasten/Process calls to kernel]]\n- Concurrency \u0026 Synchronization  \n- Scheduling  \n- Virtual Memory  \n- I/O  \n- Disks, File systems, Network file systems  \n- Protection \u0026 Security  \n- Virtual machines  \n- Will often use Unix as the example  \n\nMost OSes heavily influenced by Unix (e.g. OS161)  \nWindows is a notable exception\n\n## Synchronization primitives\nShared buffers / data are on the heap to allow multiple threads to access them. Global data is also shared.\n\nWe need H/W support to implement synchronization primitives because we are trying to protect shared data. If we use a shared data object then we have the same problem all over again. So we implement these locks using hardware.\n\n### Lock \nWill lock the CPU from any parrelalization/concurrency to avoid any data race conditions. \n\n### Condition variable\nMake a thread wait for a variable to change. This allows threads to be in a blocked state instead of ready state when waiting on a variable. This saves CPU cycles. This is also implemented using hardware primitives\n- `cond_wait`, `cond_signal`\n- we pass a condition variable and a lock to `cond_wait`\n\t- because we want to check if cond_var is changed. \n\nWait\n- place yourself on the queue\n- release the lock\n- wait signal\n- receive signal -\u003e lock again\n\nEasy way to implement this is a queue. Condition variable has a queue of threads waiting on it.\n\n### Semaphores\n..............................................................\n\n## Deadlocks\nIf we acquire locks in different orders we can have a deadlock situation.\n```\nThread 1:\n\tacquire lock a\n\tacquire lock b\n\tunlock a\n\tunlock b\nThread 2:\n\tacquire lock b\n\tacquire lock a\n\tunlock b\n\tunlock a\n```\n- here t1 can acquire a, t2 acquire b, then t1 stuck trying for b and t2 stuck trying for a\n- It is convention to unlock in the order acquired\n\n1. Limited access (mutual exclusion - resource shared by finite users)\n2. No preemption (once resource granted, can't be taken away)\n3. Multiple independent requests (hold and wait)\n\t1. don't ask all at once (waits for next resource while holding one)\n4. Cirularity in graph of requests\n\n\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-06\ntags: [[Operating system]], [Course outline](Zettelkasten/Course%20outline.md)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Operating-system-scheduler":{"title":"Kernel scheduling","content":"# Kernel (OS) scheduler\nThere are different ways of deciding how to schedule processes.\n- some options, FIFO/Round-robin, priorities etc..\n\n\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-12\ntags: [Operating System](Operating%20System.md), [Operating Systems - CS 350](Operating%20Systems%20-%20CS%20350.md)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Operating-system-threads":{"title":"Operating system threads","content":"# Operating system threads\n\nA thread is abstractly similar to a process. Threads allow concurrenct **within a userspace** whereas processes allow concurrency in the kernel space by running multiple programs concurrently.\n- Threads all belong to a process. Killing a [[Processes | process]] kills all its threads.\n\nThreads share the parent process' address space.\n\n\nEach thread has a separate stack t\n\t\n## Creating a thread\nWe pass a pointer to the function within our process that we want our thread to run on. \n- notice when we fork a process it continues on the next line we don't specify a line \n\n## n : m (no to m) threading\nWe usually have n \u003c m (user to kernel threads) \n- kernel threads are more expensive so really we just want usually 1 thread per processer\n- then each virtual user thread is able to run on multiple kernel threads (that way we can take advantage of multiprocessor cpu)\n\n## Concurrency solution requirements\nWe need a way to be able to protect **critical sections** in code where concurrency can break things.\n\nMutual exclusion\n- No two threads can be in a critical section at the same time\nProgress\n- If no thread is in a critical section then *a* thread will get in\nBounded waiting\n- If thread A is trying to get in, thread B can't repeatedly exit and enter forever\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-31\ntags: [[Operating Systems - CS 350]], [[Operating System]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Operating-system-timer":{"title":"Operating system timer","content":"# Operating system timer\nThe hardware has a timer which executes a specific code which is defined on boot by the **trap table** see [Operating system trap](Zettelkasten/Operating%20system%20trap.md)\n\nThe hardware has responsibiltity for saving key information when the timer fires s.t. the OS can resume the process that was running before the timer interrupted.\n\n\nThe OS starts the timer with a priviledged instruction.\n- OS can also stop the timer with a priviledged instruction\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-26\ntags: [Operating System](Zettelkasten/Operating%20System.md)","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Operating-system-trap":{"title":"Operating system trap","content":"# Operating system trap\nA trap is a request for the CPU to interrupt current code and elevate to **kernel mode**\n\nWhen a process calls a trap the kernel must know what code to excecute. For that there are **Trap tables** which are defined on boot up and inform the CPU of what to execute for specific hardware traps.\n\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-26\ntags: [Processes](Zettelkasten/Processes.md), [Operating System](Zettelkasten/Operating%20System.md), ","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/PPDAC-study-process":{"title":"PPDAC study process","content":"# PPDAC study process\nProblem -\u003e Plan -\u003e Data -\u003e Analysis -\u003e Conclusion\n\n**Problem** and **Plan** step are the very critical part of desigining a study. The analysis and conclusion are \"easy\" if a study was designed well statistically from the start.\n\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-02-03\ntags: [[Statistics]], [[Statistics 241]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Page-rank-algorithm":{"title":"Page rank algorithm","content":"# Page rank algorithm\n\nAlgorithm for ranking web pages\n\nWe use [[Markov matrices]] to represent probailities that we view a certain web page.\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-02-03\ntags: [[Algorithms]], [[Numerical Computation - CS 370]]","lastmodified":"2022-08-19T04:48:18.778352934Z","tags":null},"/Zettelkasten/Patric-step":{"title":"Patric step","content":"# Patric step\n\n## Technique\n1. Stand and raise one leg off the floor slight in front of you\n2. Move the lifted foot forward until you can bend your supporting knee so that the lifted food barely touches the ground and back up.\n3. End goal is to bend through the entire range of motion of the supporting leg.\n\n![](Zettelkasten/Pasted%20image%2020220818113821.png)\n\n## Why\nThis is simulating reverse step strength. There are no studies on reverse step strength benefits, but there are studies on link between step down test and chronic pain.\n\nThis is strengthening the knee over toe position.\n### References\n1. \n\n---\nstatus: #üå±             \ndate: 2022-08-18           \ntags: [Knee ability zero](Knee%20ability%20zero.md)           ","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Physics-1-Phys-111":{"title":"Physics 1 - Phys 111","content":"# Physics 1 - Phys 111\n\n## Grading\nIntroduce Yourself \nUngraded \nCourse Outline Quiz  1%\nPre/Post Course Quiz (Participation mark)  4%\nPre-Class Assignments (Participation mark)  0-10%*\nAssignments  0-10%*\niClicker Classes (Participation mark)  0-5%*\nGroup Worksheet Activity (Participation mark)  10%\nGroup Work Videos  10%\nPeer Review  5% \nWeekly Quizzes¬†  10%\nMidterm  10-15%*\nFinal Exam  20-50%*\n\n## Content\nGravity is constant 9.8 discovered by Galileo Galilei\n\n[[Kinematic equations]]\n\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-06\ntags: [Course outline](Zettelkasten/Course%20outline.md)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Poisson-distribution":{"title":"Poisson distribution","content":"# Poisson distribution\n\nMaximum likelihood estimate is the **mean** of the data\n\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-26\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Polynomial-reduction":{"title":"Polynomial reduction","content":"# Polynomial reduction\n$X \\leq_{p} Y$\n- X reduces to Y if a polynomial reduction exists to reduce X to Y\n- X is \"easier\" than Y (i.e, if we can solve Y we can solve X with polynomial factor)\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-04-04\ntags: [[Algorithms]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Prims-algorithm":{"title":"Prim's algorithm","content":"# Prim's algorithm\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-03-15\ntags: [[Graph algorithms]], [[Algorithms]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Probability-density-function":{"title":"Probability density function","content":"# Probability density function\nIntegral of a PDF is equal to 1. \n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-11\ntags: [Statistics 241](Statistics%20241.md), [Statistics](Statistics), [[Probability]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Probability-distributions":{"title":"Probability distributions","content":"# Probability distributions\n1. Binomial $f(y: \\theta) = {n \\choose y} \\theta^{y} \\cdot (1 - \\theta)^{n - y}$\n2. Exponential $f(y; \\theta) = \\frac{1}{\\theta} e^{\\frac{-y}{\\theta}}$\n3. Geometric\n4. Uniform\n5. Gaussian $Y \\sim G(\\mu, \\sigma)$ or $Y \\sim N(\\mu, \\sigma^2)$\n6. Poisson (random events in time/space)\n\n## Discrete distributions summary\n![[Pasted image 20220127202435.png]]\n## Continuous distributions summary\n![[Pasted image 20220127202519.png]]\n\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-11\ntags: [Statistics](Statistics), [Statistics 241](Statistics%20241.md)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Process-calls-to-kernel":{"title":"User process calls to kernal","content":"# User process calls to kernal\n\nUser process is running and realizes it needs to do something that requires kernal mode (priviledged operations). Jumping from a user process to a kernel level is called a [[Operating system trap]]\n\nThere are 3 circumstances\n1.  **Interrupt** (i.e, waiting for harware)\n2. **Processor exception** (illegal execution in user mode)\n3. **System calls** (asking the kernal to perform some kernal priviledged operation)\n\nProcess interrupt\nStep 0:\n- interrupts are disabled - we are about to go into kernal mode so we need to ensure what we are about to do is not interrupted\n\t- most systems have hardware buffers to store interrupts that were there when we disabled them so we don't lose that info. So the proper term is **interrupt masked/deferred**\n\nStep 1:\n- interrupt received -\u003e save **cause** and **code** in special registers\n\nStep 2: \n- Complete executing instruction being executed then *stop*\n- copy stack pointer (**SP**), program counter (**PC**), **EFLAGS** (other important values)-\u003e to special hardware registers to keep track of them\n\t- These values are copied to special registers\n- there is a special place in hardware register that points to **interrupt service routine**\n- another special register points to **interrupt stack**\n\nStep 3:\n- Set **SP** to **interrupt stack**\n\nStep 4:\n- copy **SP**, **PC**, **EFLAGS**, **CAUSE/CODE** registers to kernal interrupt stack\n\nStep 5:\n- Set **PC** to **interrupt service routine**\n- First instruction is generally to push **all registers** onto stack (this instruction is called *pushad*-push all double). We are saving here **general purpose** registers as opposed to the special registers we already saved.\n\t- All the stuff saved on the *interrupt stack* is called the **trapframe** (in the context of CS 350)\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-17\ntags: [Operating Systems - CS 350](Zettelkasten/Operating%20Systems%20-%20CS%20350.md), [Processes](Zettelkasten/Processes.md)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Process-control-block":{"title":"Process control block","content":"# Process control block\nA fancy term for a C struct which contains key information about a process.\n- sometimes called a **process descriptor**\n\nExample process control block:\n```c\n// the registers xv6 will save and restore\n// to stop and subsequently restart a process\nstruct context {\n\tint eip;\n\tint esp;\n\tint ebx;\n\tint ecx;\n\tint edx;\n\tint esi;\n\tint edi;\n\tint ebp;\n};\n// the different states a process can be in\nenum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };\n// the information xv6 tracks about each process\n// including its register context and state\nstruct proc {\n\tchar *mem;                  // Start of process memory\n\tuint sz;                    // Size of process memory\n\tchar *kstack;               // Bottom of kernel stack\n\t\t                        // for this process\n\tenum proc_state state;      // Process state\n\tint pid;                    // Process ID\n\tstruct proc *parent;        // Parent process\n\tvoid *chan;                 // If !zero, sleeping on chan\n\tint killed;                 // If !zero, has been killed\n\tstruct file *ofile[NOFILE]; // Open files\n\tstruct inode *cwd;          // Current directory\n\tstruct context context;     // Switch here to run process\n\tstruct trapframe *tf;       // Trap frame for the // current interrupt\n};\n```\n- The xv6 Proc Structure (unix-like teaching OS)\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-17\ntags: [Operating Systems - CS 350](Zettelkasten/Operating%20Systems%20-%20CS%20350.md), [Operating System](Zettelkasten/Operating%20System.md), [Processes](Zettelkasten/Processes.md)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Process-creation":{"title":"Process creation","content":"# Process creation\n\n1. Load code and static data into from disk/SSD into memory\n\t1. Earlier OS's would load everything at once. Nowadays OS will load this **lazily** when it's needed using [[Paging]] and [[Swapping]]\n2. The OS will setup some arguments in memory such as argc and argv.\n3. Linux gives each running process 3 default [[File descriptors]] stdin, stdout, stderr\n4. Run's the entry point main()\n\nSome unix ways of creating processes are `fork()`, `exec()`, and `wait()` for waiting on a created process to complete\n\n\n## Fork()\nCalling `fork()` spawns a new process which will execute as if it were returning from the `fork()`.\n- The child process has return value of 0 from `fork()`\n- The parent process has return valud of the *child PID* from `fork()`\n\nSince we have two processes running we do not know the order that they will execute. The child or the parent could execute in different orders. \t\n\n## Wait() and waitpid()\n`wait()` will wait for the child process to terminate before continuing from that line\n```c\n// spawn child process to do something\nint rc_wait = wait(NULL);\nprintf(\"Child process complete, I am the parent\");\n```\n\nThere are some cases where wait() returns before the child process ends.\n\nMore complete alternative is `waitpid()`\n\n## Exec() and variants\nOn unix there are some variants:  `exec(): execl, execlp(), execle(), execv(), execvp(), and execvpe()`\n\nExec loads the code and static data from the executable and **replaces** the current code segment with it.\n```c\nchar *myargs[3];\nmyargs[0] = strdup(\"wc\"); // program: \"wc\" (word count)\nmyargs[1] = strdup(\"p3.c\"); // argument: file to count\nmyargs[2] = NULL; // marks end of array\nexecvp(myargs[0], myargs); // runs word count\nprintf(\"this shouldn‚Äôt print out\");\n```\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-25\ntags: [Operating System](Zettelkasten/Operating%20System.md), [Processes](Zettelkasten/Processes.md), [Operating Systems - CS 350](Zettelkasten/Operating%20Systems%20-%20CS%20350.md)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Processes":{"title":"Processes","content":"# Processes\nA process is a program that is running on the OS (a program that is running is a process). \n- Chrome.exe is a program, clicking Chrome.exe to start it starts a process.\n\nThroughput\n- How many processes a CPU can handle per (some) time\n\nA process has its own view of the machine\n- its own address space, its own open files, its own virtual cpu, ...\n- it's memory is called virtual memory (since it is a chunk of total RAM)\n\nProcess API\n- Create, Destroy, Wait, Miscellaneous control (e.g, suspend), Status\n- [[Process creation]]\n\n\n\nThe OS maintains a [[Process list]] which is combrised of many  [Process control block](Process%20control%20block)s to keep track of the different processes\n\n\nHow does the OS allow execution of different processes?\n- [Limited direct execution](Zettelkasten/Limited%20direct%20execution.md)\n[Process calls to kernel](Zettelkasten/Process%20calls%20to%20kernel.md)\n## References\n1. https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf\n\n---\nstatus:\ndate: 2022-01-10\ntags: [Operating Systems - CS 350](Operating%20Systems%20-%20CS%20350.md), [Operating System](Operating%20System.md), [Programming](Programming)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Proof-that-travelling-salesman-problem-cant-be-approximated":{"title":"Proof that travelling salesman problem can't be approximated","content":"# Proof that travelling salesman problem can't be approximated\nwe prove that TSP can't be approximated well by showing an approximation for TSP -\u003e Hamiltion Cycle is solvable in poly-time\nassume some algorithm A approximates TSP with factor p\nthen create a new graph G' which has edge-weights 1 if the edge is in G, otherwise edge weight of p*|V(G)| + 1 \nthen approximating TSP on this graph returns an optimal answer within a factor of optimal solution\nif no hamiltonian cycle exists then the TSP on G' is going to be at least |V(G)| - 1 + p*|V(G)| + 1  = 2p|V(G)| \u003e p|V(G)|\nsimilarly if a hamiltonian cycles exists then approximation algorithm on TSP must be less than p|V(G)|\nso if approximation algorithm returns value \u003c p|V(G)| hamiltonian cycle exists\n\n### Generalized\nThe proof of Theorem 35.3 serves as an example of a general technique for\nproving that we cannot approximate a problem very well. Suppose that given an\nNP-hard problem X , we can produce in polynomial time a minimization prob-\nlem Y such that ‚Äúyes‚Äù instances of X correspond to instances of Y with value at\nmost k (for some k), but that ‚Äúno‚Äù instances of X correspond to instances of Y\nwith value greater than pk. Then, we have shown that, unless P D NP, there is no\npolynomial-time p-approximation algorithm for problem Y .\n\n### References\n1. theorem 35.3 in CLRS\n\n---\nstatus: #üå± \ndate: 2022-04-18\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Publishing-obsidian-vault-for-free":{"title":"Publishing obsidian vault for free ","content":"# Publishing obsidian vault for free\n## Goal\nTo pubish Obsidian notes online on my website in a way that is free and doesn't introduce a dependency on a specific closed source tool / software.\n\nRequirements:\n- easy to use\n- static site that can be managed with netlify\n\n\n## Solutions\n1. https://www.mentalnodes.com/a-gardening-guide-for-your-mind\n\t1. doesn't have a graph view\n2. https://refinedmind.co/obsidian-jekyll-workflow\n\t1. obsidian - jekyll workflow, doesn't seem to support graph view\n\n## References\n1.  https://garden.bianca.digital/about\n\n---\nstatus: #üîµ #üå±  \ndate: 2021-12-07\ntags: [[Personal website]], \n","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Reading-list":{"title":"Reading list ","content":"# Reading list\n- The art of learning waitzkin \n\n## References\n1. \n\n---\nstatus: #üí≠\ndate: 2021-11-28\ntags: [[]]\n","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Recursive-algorithm":{"title":"Recursive algorithm ","content":"# Recursive algorithm\n\n## Recursive algorithm design\n1. Define a subproblem (state what it computes not just how to)\n2. Relate subproblems recursively\n3. Topological order to make sure subproblem dependencies are acyclic\n4. Base cases of the recursion\n5. Solve original problem via subproblem\n\n## Defining subproblems\nIf input is a **sequence** some good options for subproblems are:\n- prefixes a[:i]\n- suffixes a[i:]\n- substrings a[i:j]\n\nIf **multiple inputs** good options for subproblems are:\n- multiply subproblem spaces\n\t- e.g, (number of suffixes of A $\\times$ number of suffixes of B)\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2021-11-23\ntags: [[Dynamic programming]]\n","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Relative-likelihood-function":{"title":"Relative likelihood function","content":"# Relative likelihood function\n\n$\\hat{\\theta}$ is the maximum likelihood probability.\n\nRelative likelihood function\n$$R(\\theta) = \\frac{L(\\theta)}{L(\\hat{\\theta})}$$\n- notice the denominator is a constant\n\nThere is a log-likelihood function just $\\log{L(\\theta)}$\n- mainly used for manipulating (e.g, deriving) likelihood functions easily \n\n[[Likelihood function for independent experiments]]\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-20\ntags: [Statistics](Statistics), [Statistics 241](Zettelkasten/Statistics%20241.md)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Remove-nth-element-from-back-of-list":{"title":"Remove nth element from back of list ","content":"# Remove nth element from back of list\n\nSolution:\n- Use two pointers: one fast one that is iterated n times initially\n- then iterate the two until fast one is at the end, then the slow one is at `end - n`\n- **note:** if the fast reaches end in initial iterations then the element is the first element and we must delete it through `return head-\u003enext`\n\n```c++\nint count = n; \nListNode* tail = head;\nListNode* cur = head;\n\nwhile (count--) {\n\ttail = tail-\u003enext;\n}\nif (tail == nullptr) return head-\u003enext;\n\nwhile (tail-\u003enext != nullptr) {\n\tcur = cur-\u003enext;\n\ttail = tail-\u003enext;\n}\n\ncur-\u003enext = cur-\u003enext-\u003enext;\nreturn head;\n```\n## References\n1. https://leetcode.com/problems/remove-nth-node-from-end-of-list/\n\n---\nstatus: #üü¶ #üåû\ndate: 2021-11-09\ntags: [[Programming question]], [[Two pointer]], [[Leetcode]]\n","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Run-chart":{"title":"Run chart","content":"# Run chart\nBasically value over time (canadian dollar vs. usd)\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-13\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Same-tree":{"title":"Same tree ","content":"# Same tree\nProblem:\n- check two binary trees are the same\n\nSolution:\n- dfs check each one node is equal\n\nImplementation:\n```c++\nbool dfs(TreeNode* p, TreeNode* q) {\n\tif (p == nullptr \u0026\u0026 q == nullptr) return true;\n\tif (p == nullptr || q == nullptr) return false;\n\tif (p-\u003eval == q-\u003eval) \n\t\treturn dfs(p-\u003eleft, q-\u003eleft) \u0026\u0026 dfs(p-\u003eright, q-\u003eright);\n\treturn false;\n}\n\nbool isSameTree(TreeNode* p, TreeNode* q) { \n\treturn dfs(p, q);\n}\n```\n\n## References\n1.  https://leetcode.com/problems/same-tree\n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-28\ntags: [[Programming question]], [[Leetcode]], [[Leetcode easy]]\n","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Sample-correlation":{"title":"Sample correlation","content":"# Sample correlation\nThe sample correlation is a measure of a **linear** relationship\n\nInterpretation\n- if the value of r is close to 1 we have a strong positive linear relationship\n- if the value of r is close to 0 we have no linear relationship\n- if the value of r is close to -1 we have a strong negative linear relationship\n\n\nWhy is $$[(x_i - \\bar{x})(y_i - \\bar{y})]$$ positive with positive correlation and ndegative with negative relationship.\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-13\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Sample-kurtosis":{"title":"Sample kurtosis","content":"# Sample kurtosis\nSample kurtosis =\n$$\\frac{\\frac{1}{n}\\Sigma_{i=1}^n(y_i - \\bar{y})^4}{[\\frac{1}{n}\\Sigma_{i=1}^n(y_i-\\bar{y})^2]^2}$$\n\nVisually\n![](Zettelkasten/Pasted%20image%2020220111110719.png)\n\nLarge kurtosis characterstics\n- large tails\n- large peak\n\nIf the data is generated from Gaussian distribution -\u003e kurtosis should be close to 3.\n\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-11\ntags: [Statistics](Statistics)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Sample-skewness":{"title":"Sample skewness","content":"# Sample skewness\n\nsample skewness\n$$\\frac{\\frac{1}{n}\\Sigma^n_{i=1}(y_i-\\bar{y})^3}{[\\frac{1}{n}\\Sigma_{i=1}^n(y_i-\\bar{y})^2]^\\frac{3}{2}}$$\n\nIf our data is symmetric $y_i - \\bar{y}$ term will have an equivalent opposite sign term which cancels it out to 0.\n- hence for symmetric data the sample skewness will be close to 0\n\nIf the sample skewness is positive we know there are more positive $(y_i - \\bar{y})^3$,\n- if there are $y_i \u003e\u003e \\bar{y}$ then the term will be much larger than 0, and so there are lots of observations to the right of the mean without symmetric equivalents (hence terms don't cancel and we have positive skewness)\n- visually this is a long right tail\n\nSample skewness is negative is opposite of the positive case\n- long left tale\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-11\ntags: [Statistics 241](Statistics%20241.md), [Statistics definitions](Statistics%20definitions.md)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Semaphores":{"title":"Semaphores","content":"# Semaphores\n`sem_wait()` decrements and sleeps if value is negative - `sem_post()` increments value\n\n```C\nint sem_wait(sem_t *s) {\n\t// decrement the value of semaphore s by one\n\t// wait if value of semaphore s is negative\n}\n\nint sem_post(sem_t *s) {\n\t// increment the value of semaphore s by one\n\t// if there are one or more threads waiting, wake one\n}\n\nsem_t m;\nsem_init(\u0026m, 0, X); // initialize to X; what should X be?\n\nsem_wait(\u0026m);\n// critical section here\nsem_post(\u0026m);\n```\n\n## Binary semaphore ([[Thread locks | lock]])\nSet a semaphore to initial value of 1 and use it as a lock. \n\n## Sempahores as ordering primitives \nCan be used basically as [[Condition variables]]\n\nInitial value of 0 -\u003e create child -\u003e sem_wait() -\u003e child calls sem_post() -\u003e parent is woken up since value hits 0\n\n## Producer consumer problem (bounded buffer)\n```c\nvoid *producer(void *arg) {\n\tint i;\n\tfor (i = 0; i \u003c loops; i++) {\n\t\tsem_wait(\u0026empty); // Line P1\n\t\tsem_wait(\u0026mutex); // Line P1.5 (MUTEX HERE)\n\t\tput(i); // Line P2\n\t\tsem_post(\u0026mutex); // Line P2.5 (AND HERE)\n\t\tsem_post(\u0026full); // Line P3\n\t}\n}\n\nvoid *consumer(void *arg) {\n\tint i;\n\tfor (i = 0; i \u003c loops; i++) {\n\t\tsem_wait(\u0026full); // Line C1\n\t\tsem_wait(\u0026mutex); // Line C1.5 (MUTEX HERE)\n\t\tint tmp = get(); // Line C2\n\t\tsem_post(\u0026mutex); // Line C2.5 (AND HERE)\n\t\tsem_post(\u0026empty); // Line C3\n\t\tprintf(\"%d\\n\", tmp);\n\t}\n}\n```\n\n## Reader-writer lock\nAllow multiple readers but only one writer.\n- they often cause a lot of overhead so vareful consideration is required to see if they provide any benefit over simpler primitives\n\n\n### References\n1. https://pages.cs.wisc.edu/~remzi/OSTEP/threads-sema.pdf\n2. ‚ÄúThe Little Book of Semaphores‚Äù by A.B. Downey http://greenteapress.com/semaphores/. Good book on semaphores with puzzles to learn them.\n\n---\nstatus: #üå± \ndate: 2022-03-01\ntags: [[Concurrency]], [[Operating System]], [[Operating Systems - CS 350]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Sissy-squat":{"title":"Sissy squat","content":"# Sissy squat\n\n## Technique\n1. Stand up and bend knees to the ground controllably. \n2. To make it easier add something to rest on behind you to allow control until easier depth. To make it harder use a stair case for even lower depth.\n![](Zettelkasten/Pasted%20image%2020220818120059.png)\n![](Zettelkasten/Pasted%20image%2020220818120107.png)\n![](Zettelkasten/Pasted%20image%2020220818120116.png)\n\n## Why\nSimilar benefits to [Ass to grass split squat](Ass%20to%20grass%20split%20squat.md) and [Patric step](Patric%20step.md) but it targets muscles at more demanding levels. Ankle mobility is also pushed to limits.\n### References\n1. \n\n---\nstatus: #üå±             \ndate: 2022-08-18           \ntags: [Knee ability zero](Knee%20ability%20zero.md)           ","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Solving-recurrence-relations":{"title":"Solving recurrence relations","content":"# Solving recurrence relations\nTwo basic approaches\n- recursion tree method\n- guess a solution and prove by induction\n\n[[Master theorem]]\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-16\ntags: [Algorithms](Algorithms), [Algorithms - CS 341](Zettelkasten/Algorithms%20-%20CS%20341.md)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Statistical-models":{"title":"Statistical models","content":"# Statistical models\n\"All models are incorrect, but some are useful\" - George Box\n\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-18\ntags: [Statistics 241](Zettelkasten/Statistics%20241.md), [Statistics](Statistics)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Statistical-moment":{"title":"Statistical moment","content":"# Statistical moment\nDefinition . The **nth moment** of a random variable X is defined to be $E[Xn]$. The nth central moment of $X$ is defined to be $E[(X‚àíEX)n]$. \n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-27\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Statistical-study-errors":{"title":"Statistical study errors","content":"# Statistical study errors\nThe target population is not the same as the study population, so there is an error when trying to approximate the target via a study sample.\n\nThere is a sample error when measuring returns from the study (for example people giving permission to be sampled).\n\nThere is a measurement error. From the people who do agree there is a measurement error in how we colelct the data.\n\nPerfect theoretical population -\u003e error in choosing a subset -\u003e error in sample of subset -\u003e error in measuring sample\n- Perfect -\u003e study error -\u003e sample error -\u003e measurement error\n![[Pasted image 20220203104524.png]]\n\n**Notice** if we have truly random sampling there cannot be sampling error since the sample is perfectly chose. This is usually impossible to achieve.\n\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-02-03\ntags: [[Statistics 241]], [[Statistics]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Statistics-241":{"title":"Statistics 241","content":"# Statistics 241\n- Online exams will be open book\n\nA list of [[Zettelkasten/Statistics definitions]] \n\n[[Statistics notations]]\n\nShould be very comfortable with the [[Central limit theorem]]\n## Content\n[[Measure of central tendancy or location]]\n[[Measures of variability or dispersion]]\n[[Probability distributions]]\n[[Probability density function]]\n[[5 number summary]]\n[[Graphical data summaries]]\n\n[[Bivariate data]]\n- [[Sample correlation]]\n- [[Relative risk]]\n\n[[Statistical models]]\n[[Maximum likelihood estimation]] \u0026 [[Zettelkasten/Relative likelihood function]]\n\n[[PPDAC study process]]\n[[Statistical study errors]]\n\n### Estimation (Chapter 4)\nChoosing a statistical model. There are two models to think about.\n- Model for the target population\n- Model for the study population, i.e, where we get our study sample\n\n\n## Grading\n- 25% midterm (20% if online)\n- 25% midterm (20% if online)\n- 50% final (20% if online)\n\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-06\ntags: [Course outline](Zettelkasten/Course%20outline.md), [Statistics](Statistics)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Statistics-definitions":{"title":"Statistics definitions","content":"# Statistics definitions\nList of statistics words and their definitions.\n\n**Warning:** common mistakes on exams are definitions that are not precise\n- all UW students (does this include current/alumni and undergrad/grad ??)\n\n## The list\n1. **Unit** - a thing (person, place, etc.) that we can take a measurement of\n2. **Population** - a collection of units (all persons aged 90+)\n3. **Process** - a system that produces units (over time)\n\t- hits on a website can be considered as a process\n4. **[Variates](Variates.md)** - characteristics of units usually represented with X, Y, Z\n\t- continuous, discrete, categorical, ordinal, complex\n5. **Attributes** - an attribute (function) of a population (not sample) or process is a *function of a variate* defined for *all units* in the pop. / process\n6. **Sample survey** - a study which uses a sample population to represent a *finite* population (election surveys)\n7. **Observational study** - a study where information is collected about a process/pop. without any attempt to change any variates. (measuring alcohol levels before lectures on monday mornings)\n8. **Experimental study** - a study where the researcher changes or sets the values for one more more variates (telling a group of students their blood alochol level will be measured vs. a group where they aren't told)\n9. The (sample) *range** is defined as the maximum observation - minimum observation (max difference)\n10. Sample **mean**, **median**, **mode** (see [Measures of variability or dispersion](Measures%20of%20variability%20or%20dispersion.md))\n10. Sample **variance**, standard **deviation**\n11. The $p^{th}$ **quantile**, **percentile** a percentile is just quantile\\*100\n12. The **interquartile range (IQR)** defines as IQR = q(0.75) - q(0.25). \n\t- this can be considered a robust alternative to sample range\n\t- becareful if the data is discrete (is the interval closed or open??)\n13. **[[Sample skewness]]**\n14. **[[Sample kurtosis]]**\n15. **[[Gaussian distribution]]**\n16. [[Maximum likelihood estimation]] / [[Relative likelihood function]]\n17. [[Probability distributions]] ([[Poisson distribution]], [[Gaussian distribution]], [[Binomial distribution]], [[Geometric distribution]])\n18. [[qqplot]]\n19. [[Method of moment estimates]]\n20. [[Statistical moment]]\n21. [[PPDAC study process]] (Problem, Plan, Data, Analysis, Conclusion)\n22. [[Target trials]] (not required for this course)\n23. [[Target population]] or target process\n\n\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-06\ntags: [Statistics 241](Statistics%20241.md), [[Statistics]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Statistics-notations":{"title":"Statistics notations","content":"# Statistics notations\nWe use lower case letters for observations\n\nOrdered sample\n- $y_{(1)} \\cdots y_{(n)}$ denotes the ordered samples i.e $y_{(i)}\u003cy_{(i+1)}$\n\nAssymetry of distribution leads to the difference between mean and median.\n\n## References\n1. \n\n---\nstatus:\ndate: 2022-01-11\ntags: [Statistics 241](Statistics%20241.md), [Statistics](Statistics)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Supplement-stack":{"title":"Supplement stack ","content":"# Supplement stack\n\nSupplements:\n- multivitamin \n- Vitamin D x 5000 IU\n- Omega 3 x 3000\n- Iron \n- Ashwaganda KSM-66 x 600mg\n- 2g l-carnitine\n- \n## References\n1. \n\n---\nstatus:\ndate: 2021-11-25\ntags: [[Health]], [[Personal performance]]\n","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Synchronisation-primitives":{"title":"Synchronisation primitives","content":"# Synchronisation primitives\nPerforming groups of instructions together as **atomic** is an important concept. They are always seen as either all completed or none, never inbetween state. These are sometimes referred to as [[Transactions]]\n\n## Synchronization primitives\nShared buffers / data are on the heap to allow multiple threads to access them. Global data is also shared.\n\nWe need H/W support to implement synchronization primitives because we are trying to protect shared data. If we use a shared data object then we have the same problem all over again. So we implement these locks using hardware.\n\n### [[Thread locks | Locks]]\nWill lock the CPU from any parrelalization/concurrency to avoid any data race conditions. \n\n### [[Condition variables]]\nMake a thread wait for a variable to change. This allows threads to be in a blocked state instead of ready state when waiting on a variable. This saves CPU cycles. This is also implemented using hardware primitives\n- `cond_wait`, `cond_signal`\n- we pass a condition variable and a lock to `cond_wait`\n\t- because we want to check if cond_var is changed. \n\nWait\n- place yourself on the queue\n- release the lock\n- wait signal\n- receive signal -\u003e lock again\n\nEasy way to implement this is a queue. Condition variable has a queue of threads waiting on it.\n\n### [[Semaphores]]\n\n\nSee [[Deadlocks]] to see issues with sync.\n\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-02-28\ntags: [[Operating System]], [[Concurrency]], [[Operating Systems - CS 350]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/TV-Shows-List":{"title":"TV Shows List","content":"# TV Shows List\n\n\n## Currently watching\n- Attack on Titan\n- Peaky Blinders\n- Succession \n- Game of Thrones\n\n## Watch queue\n- Better Call Saul\n- Mr Robot\n- Fargo\n- The wire\n- Westworld\n- Chernobyl\n- The sopranos\n- Dark\n- Billions\n- Jujitsu kaisen\n- Narcos Mexico\n\n## Favourites List\n- Breaking Bad\n- Peaky Blinders\n- Attack on Titan\n- Prison Break\n- Mr Robot\n- Succession\n- Fargo\n- Sherlock\n- Game of Thrones\n- Black Mirror\n- Love Death Robots (Season 1)\n- Stranger Things (Season 1)\n\n\n## References\n1. \n\n---\nstatus:\ndate: 2021-12-29\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Tag-taxonomy":{"title":"Tag Taxonomy ","content":"# Tag Taxonomy\nNested tag system for tagging notes\n\n- üì• Inbox | inputs i.e, entries that I will be working on (not flushed out evergreen yet)\n\t- üìö | Note on a concept that already exists\n\t\t- Note's of a video / podcast / book are all grouped here (separating them seems contradictory with conceptual note taking)\n\t- üí≠ | Thought  i.e, not an established concept (at least to my knowledge)\n- üìùNotes | Note entries that are more flushed out than an inbox entry\n\t- üå± | Need to flush out (doesn't describe the concept well)\n\t- üåû | Describes the concept well but needs stronger linking\n\t- üå≤ | Evergreen atomic concept with strong links  \n- ‚úÖTo-Do | items with a task that needs to be done\n\t- üü© Easy work\n\t- üüß Medium work\n\t- üü• Lots of work \n- üó∫Ô∏è Maps of Content | the structure that emerge naturally in notes\n- üï∏Ô∏è Graph groupings\n\t- üü§ Conceptual notes ([[Evergreen notes | Evergreen]] / Zettelkasten notes)\n\t- üîµ Implementation notes |  non-conceptual implementations (e.g, bfs in python)\n\t- üü£ Proper noun notes | notes about specific nouns (person, application)\n\t\t- not conceptual so not Evergreen, weakly evergreen since they're revisited\n\t- ‚ö™ Project documents (business plans, room designs, etc...)\n- üè∑Ô∏è Tag | for links to empty files (i.e, topic links that don't yet exist)\n\t- Some file linking to [[Programming]] where the programming file is empty with üè∑Ô∏è\n\t- Allows for quickly finding such empty topic/tag files \n- ü¶¥ Utility note | not really notes - utility files such as tracking lists, etc.\n\t- Bone emoji because such files usually go stale and die off\n\n## [[Note taxonomy]]\nThese tags are used to label the note's identiy. So the \"tag taxonomy\" actually describes the note's taxonomy\n\n## References\n- Bryan Jenks https://youtu.be/wB89lJs5A3s?t=4000\n---\nstatus: #üå≤ \ndate: 2021-11-07\ntags: [[PKM system goals]], [[Evergreen notes]], [[Note taxonomy]]\n","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Thread-API":{"title":"Thread API","content":"# Thread API\n\n`pthread_create()`, `pthread_join()`\n\nSee [[Thread locks]]\n```c\npthread_mutex_t lock;\npthread_mutex_lock(\u0026lock);\nx = x + 1; // or whatever your critical section is\npthread_mutex_unlock(\u0026lock);\n```\n- **this code is broken** need to initialize the lock and check error code\n\n[[Condition variable]]\n### References\n1. https://pages.cs.wisc.edu/~remzi/OSTEP/threads-api.pdf  \n\n---\nstatus: #üå± \ndate: 2022-02-28\ntags: [[Operating Systems - CS 350]], [[Operating System]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Thread-locks":{"title":"Thread locks","content":"# Thread locks\nA lock is **available** or **acquired**\n- available: unlocked or free\n- acquired: locked or held (by us)\n\n## Evaluating locks\n1. Correctness: They provide mutual exculsion (*mutex*)\n2. Fairness: A thread waiting for a lock eventually gets it (no **starvation**)\n3. Performance: CPU cycle efficiency\n\n## Naive locks (no special hardware)\nWe can use a flag and simply spin (infinite loop checking `flag==1`) when trying to lock the flag. Unlocking sets flag to 0. \n- This doesn't work. \n- T1  checks `flag == 1 == false` , T2 sets flag to 1, T1 sets flag to 1\n\t- both threads think they acquired it\n\t- this is becase to lock it we `test` then `set`, inbetween them someone else can `set`\n\n## Hardware primitives (special instructions)\n### test-and-set primitive hardware\n```c\nint TestAndSet(int *old_ptr, int new) {\n\tint old = *old_ptr; // fetch old value at old_ptr\n\t*old_ptr = new; // store ‚Äônew‚Äô into old_ptr\n\treturn old; // return the old value\n}\n```\n- atomically returns the old value and sets it to a new value\n\n### load-linked and store-conditional\nload-linked loads a value\n- store-conditional stores *only if* no other value has been written to that variable\n\n### fetch-and-add\natomically increments value and returns old\n- implement ticketing locks where threads get a place in line and go when it is their turn\nticketing locks ensure **fairness**\n\n## Implementing locks\n### spin locks\n```c\nvoid init(lock_t *lock) {\n\t// 0: lock is available, 1: lock is held\n\tlock-\u003eflag = 0;\n}\n\nvoid lock(lock_t *lock) {\n\twhile (TestAndSet(\u0026lock-\u003eflag, 1) == 1)\n\t; // spin-wait (do nothing)\n}\n\nvoid unlock(lock_t *lock) {\n\tlock-\u003eflag = 0;\n}\n```\n- these require a **preemptive [[Operating system scheduler | scheduler]]** since the thread needs to be interrupted so that another thread can free the lock while it's spinning\n\n### Futex locks \nPut a thread to sleep and wake them up when the lock is free to avoid spinning.\n- ensure **fairness** and increase **performance**\n\n### Hybrid locks\n**Two-phase** are instance of hybrid locks and will spin the first time they try to get a lock. Spinning the first time is useful if you end up getting the lock since it saves time. If they fail they enter a second phase where they use a **futex** to sleep and wait.\n\n\n### References\n1. https://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks.pdf \n\n---\nstatus: #üå± \ndate: 2022-02-28\ntags: [[Operating System]], [[Threads]], [[Operating Systems - CS 350]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Tibialis-raise":{"title":"Tibialis raise","content":"# Tibialis raise\n\n## Technique\n1. Stand against a wall and move feet out to a comfortable position. Make sure feet aren't slippery against floor\n2. Raise toes and hold for 2 seconds at the top\n3. Feet further from wall makes it harder, closer makes it easier\n4. The higher the heel the harder (flat shoes are easier)\n\n![](Zettelkasten/Pasted%20image%2020220818110916.png)\n\n## Why\nTibialis is responsible for slowing you down when moving forward. When playing a sport and moving fast you put a lot of force on the tibialis and whatever isn't handled by it goes to your knee.\n### References\n1. \n\n---\nstatus: #üå±             \ndate: 2022-08-18           \ntags: [Knee ability zero](Knee%20ability%20zero.md)           ","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Unique-paths":{"title":"Unique paths ","content":"# Unique paths\nProblem:\n\nSolution:\n\nImplementation:\n```c++\nint uniquePaths(int m, int n) {\n    int dp[m];\n    fill(dp, dp + m, 1);\n    for (int j = 1; j \u003c n; ++j)\n        for (int i = 1; i \u003c m; ++ i)\n            dp[i] = dp[i] + dp[i-1];\n    return dp[m - 1];\n}\n```\n## References\n1. \n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-24\ntags: [[Programming question]], [[Leetcode]]\n","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Valid-parenthesis":{"title":"Valid parenthesis ","content":"# Valid parenthesis\nProblem: check input of ( { \\[  are all matched and closed\n\nSolution:\n- insert opening braces into stack\n- pop stack on closing brace and check it matches\n\t- if stack is empty return false\n- if stack is not empty at the end return false\n\nImplementation:\n```c++\nstack\u003cchar\u003e st;\nfor (auto c : s) {\n\tif (c == ')') {\n\t\tif (st.size() == 0) return false;\n\t\tchar t = st.top();\n\t\tif (t != '(') return false;\n\t\tst.pop();\n\t} else if (c == '}') {\n\t\tif (st.size() == 0) return false;\n\t\tchar t = st.top();\n\t\tif (t != '{') return false;\n\t\tst.pop();\n\t} else if (c == ']') {\n\t\tif (st.size() == 0) return false;\n\t\tchar t = st.top();\n\t\tif (t != '[') return false;\n\t\tst.pop();\n\t} else {\n\t\tst.push(c);\n\t}\n}\nif (st.size() != 0) return false;\nreturn true;\n```\n## References\n1. https://leetcode.com/problems/valid-parentheses/submissions/\n\n---\nstatus: #üü¶ \ndate: 2021-11-09\ntags: [[Programming question]], [[Leetcode]], [[Stack]]\n","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Validate-binary-search-tree":{"title":"Validate binary search tree ","content":"# Validate binary search tree\nProblem: validate a given tree is a bst\n\nSolution:\n- keep track of min and max values traversing from the top\n\t- when going left max value should be current, min stays the same\n\t- when going right min value should be current, max stays the same\n\nworse:\n- in order traversal and save values then check they are sorted\n\n\nImplementation:\n- with additional array space \n```c++\nvector\u003cint\u003e order;\nvoid dfs(TreeNode* cur) {\n\tif (cur == nullptr) return;\n\tif (cur-\u003eleft != nullptr) dfs(cur-\u003eleft);\n\torder.push_back(cur-\u003eval);\n\tif (cur-\u003eright != nullptr) dfs(cur-\u003eright);\n}\n\nbool isValidBST(TreeNode* root) {\n\tdfs(root);\n\tbool ans = true;\n\tfor (int i = 1; i \u003c order.size(); ++i)\n\t\tif (order[i] \u003c= order[i-1]) ans = false;\n   return ans;\n```\n\n- using max and min instead\n```c++\nint dfs(TreeNode* cur, long mn, long mx) {\n\tif (cur == nullptr) return true;\n\tif (cur-\u003eval \u003e= mx || cur-\u003eval \u003c= mn) return false;\n\tbool ans = true;\n\tif (cur-\u003eleft != nullptr) ans \u0026= dfs(cur-\u003eleft, mn, cur-\u003eval);\n\tif (cur-\u003eright != nullptr) ans \u0026= dfs(cur-\u003eright, cur-\u003eval, mx);\n\treturn ans;\n}\n\nbool isValidBST(TreeNode* root) {\n   return dfs(root, (long) INT_MIN - 1, (long) INT_MAX + 1);\n}\n```\n\n## References\n1. https://leetcode.com/problems/validate-binary-search-tree \n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-28\ntags: [[Programming question]], [[Leetcode]]\n","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Variates":{"title":"Variates","content":"# Variates\nVariates:  characteristics of units usually represented with X, Y, Z\ncontinuous - those that can theoretically be measured to infinite accuracy (height, weight, time)\n\n**discrete** - can only take finite or countably infinite values (number of car accidents)\n\n**categorical** - fall into a non-numeric category (eye colour, hair colour, etc.)\n\n**ordinal** - categories with an implied order (strongly disagree, disagree, neutral, etc..)\n- **Warning:** be very careful of ordinal variates into discrete ones\n- Days of the week is **categorical** not ordinal, since the ordering of the days is not implied there is no reason for the order. Poor Satisfactory Good has two extremes, days of the week don't.\n\n![](Zettelkasten/Pasted%20image%2020220106171634.png)\n- notice the difference in gaps between sizes and when mapping the sizes to 1,2,3,4...\n\n**complex** - more open ended responses. Usually require some processing to interpret them (twitter sentiment analysis)\n\n## Statistical importance\nUsually the type of variate determines what kind of distribution we would use to model it.\n- there are times we would deviate from these rules \n\n\n## Selft test questions\n\nWhat type of variate is measuring time to the nearest second.\n- this is continuous since in theory it could be measured infinitely (if all ages in a study can be 1 of 2 choices we probably wouldn't use a continuous distribution)\n\n## References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-06\ntags: [[Statistics]], [Statistics 241](Statistics%20241.md), [Statistics definitions](Statistics%20definitions.md)","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Virtual-memory":{"title":"Virtual memory","content":"# Virtual memory\nGoals\n- transparency : processes shouldn't be able to tell they're in virtual memory\n- efficiency : space and time efficiency of virtualization\n- protection : processes shouldn't be able to affect each other\n\n## Address space\nContains all the data required to run a program (code, stack, heap)\n\n### Address translation\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-04-26\ntags: [[]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/Word-search":{"title":"Word search ","content":"# Word search\nProblem: Return true if a word exists in a grid (can be formed sequentially in any adjacent direction)\n\nSolution:\n- run a dfs on each cell checking for the word\n- after visiting a letter temporarily switch board[i][j]='\\*' then switch it back to ensure revisting the cell doesn't count\n\nImplementation:\n```c++\nvector\u003cvector\u003cchar\u003e\u003e b;\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nbool dfs(int i, int j, int d, string\u0026 s) {\n\tif (i \u003c 0 || i \u003e= b.size()) return false;\n\tif (j \u003c 0 || j \u003e= b[i].size()) return false;\n\tif (d == s.size() - 1 \u0026\u0026 s[d] == b[i][j]) return true;\n\n\tif (b[i][j] != s[d]) return false;\n\tbool ans = false;\n\tchar c = b[i][j];\n\tb[i][j] = '*';\n\tfor (int k = 0; k \u003c 4; ++k) {\n\t   ans = ans || dfs(i + dx[k], j + dy[k], d+1, s); \n\t}\n\tb[i][j] = c;\n\treturn ans;\n}\n\nbool exist(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, string word) {\n\tb = board;\n\tfor (int i = 0; i \u003c board.size(); ++i) {\n\t\tfor (int j = 0; j \u003c board[i].size(); ++j) {\n\t\t\tif (dfs(i, j, 0, word)) {cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c j \u003c\u003c endl; return true;}\n\t\t}\n\t}\n\treturn false;\n}\n```\n## References\n1. \n\n---\nsatus: #üü¶ #üåû\ndate: 2021-11-27\ntags: [[Programming question]], [[Leetcode]]\n","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/cs341-final-exam-review":{"title":"cs341 - final exam review","content":"# cs341 - final exam review\n## Recursion \u0026 Master theorem\nT(n) = a\\*T(n/b) + c \\* n^k\n- Theta(n^k) if a \u003c b^k\n- Theta(n^k log n) if a = b^k \n- Theta(n^(log_b a)) if a \u003e b^k\n\n### Substitution\nMake a guess and inductively prove.\n- substitute the guess for T(n)\n- prove the base case (boundary)\n\n**change variables** if it helps to change the recurrence to something more common in terms of another variable\n![[Pasted image 20220415154746.png]]\n## Turing reduction\n\n## Algorithm from lectures\n2SUM - Two pointer method O(n)\n3SUM - O(n^2) : call 2SUM on each value\nCount inversions - O(n log n) : divide and conquer\nClosest points - O(n log n) : divide and conquer\n- Sort by X -\u003e split them in half\n- S \u003c- points within d of middle line, sorted by y-value\n\t- The points q, r separated by the mid-line are within 8-possible regions of each other, so sorted-by y value they are at most 8 points apart\n\t- So merging left and right closest points is O(n)\n\t\nKaratsuba multiplication : O(n^lg 3) divide and conquer\n- eliminate one of the 4 required multiplications when merging\n\nMatrix multiplication : O(n^lg 7) divide and conquer (7 multiplications instead of 8)\nMaximum disjoint sets : O(n log n) greedy\n- maximum interval count scheduling : sort by end greedy pick\n\nMinimize lateness of jobs: O(n log n)\n- sort and complete jobs in order of earliest deadline\n\nFractional knapsack: O(n log n)\n- sort by value/weight and greedily pick maximal amount\n\nSplit strings into words: O(n^2)\n- dp[k] is true if dp[j] and string[j+1, k] is a word\n\nLongest increasing subsequence: O(n^2)\n- dp[i] is the lenght of LIS ending at i\n- check all j\\\u003ci that are less than than a[i] and max of that + 1 is dp[i]\n\nLongest common subsequence LCS: O(n \\* m)\n- LCS(n[i], m[j]) = 1 + LCS(n[i-1], m[j-1]) if n[i] == m[j] \n- or max(LCS(n[i-1], m[j]), LCS(n[i], m[j-1]))\n- can use LCS to solve LIS -\u003e LCS(a, sorted a)\n\nComput edit distance : O(n \\* m)\n\nMaximum weighted intervals: O(n^2)\n- sort by end points\n- dp[i] is max weight using up to ith interval\n- dp[i] = max(dp[i-1], w[i] + dp[j] where j is latest (largest j) non-overlaping interval)\n\n0-1 Knpwsack : O(n^2)\n- order items from 1..n but no particular order\n- dp[w][i] is the maximum value using up to the ith item with weight w\n- dp[w][i] = max(\n\t- dp[w][i-1] # don't use ith item\n\t- dp[w-w[i]][i-1]  # use i )\n- you loop from w=0..W where W is maximum weight\n\nConstruct optimal binary tree: O(n^3)\nAlgorithm to compute all cut vertices: DFS\nDetecting cycle in graph: if dfs has back edge\nTopological sort of acyclic graph: \n- DFS reverse order\n\nKruskal algorithm : O(m log n)\n- Go through edges in order of weight - if edge doesn't connect two vertices in same component, add it\n\nUnion-Find DS\n\nPrim's Algorithm : O(m log n)\n- Start at a vertex and choose minimum edge that is not connected to current component\n\nDjikstra - No negative weights : O(m log n)\n\nSingle source shortest path in DAG: O(n + m)\n- remove edges with no possible path (top. sort and remove all b4 s)\n- for 1..n: for every edge (vi, vj), if di + w(vi, vj) \u003c dj \u003c- dj = di + w(vi, vj)\n\nBellman ford (dynamic prog.) - shortest no negative cycles : O(n \\* (n + m))\n- dp_i[v] = shortest path from s to v using \u003c= i edges\n- dp_i[v] = min (dp_i[v], dp_i-1[u] + w(u, v)) for all (u, v)\n\nFloyd-warshall all pairs shortest path (no neg. cycles) : O(n^3) \n- dp_i[u][v] is shortest path from u-\u003ev using intermediate vertices 1..vi\n- dp_i[u][v] = min(dp_i-1[u][v], dp_i-1[u][i] + dp_i-1[i][v])\n## Prove a problem is NP-complete\n\nNP problems are decision problems which can be verified in polynomial time given a certificate.\n\nX is NP-Comp if  (how to prove)\n- X is in NP\n- every Y in NP, Y \u003c=p X\n\n![[Pasted image 20220418172104.png]]\nTSPDec\n- is there a complete cycle with weight \u003c= k\n\n3SATDec\n- and of clauses which has 3 literals\n\n## Graph algorithm with approximations\n### Vertex Cover approx\n- Greedy remove vertex that covers the most things\n- Greedy if theres some edge uncovered (u, v)\n\t- add u, v to C and remove all edges touching them \n\nThe second one is better |C| \u003c= 2|C_opt|\n- the chosen edges form a matching (no two edges share a vertex)\n- |C_opt| \u003e= |M|\n- a vertex in C_opt covers at most one edge in |M| since they're disjoint so -\u003e |C_opt| \u003e= |M|\n- |M| = |C| / 2 since our algorithm picks each endpoint of an edge in M \n\n### Euclidean TSP approx\nBuild an MST\n- shortcut the visited nodes\n- the shortcut cycle is \u003c= 2 |weight of MST| since it decreases by triang. ineq.\n- the weight of MST \u003c= weight of TSP since removing an edge from TSP makes a tree and this is the Minimum tree\n- then short-cut \u003c= 2|MST| \u003c= 2|TSP|\n\n## Greedy algorithm \u0026 proof\n[[Greedy algorithms]]\nTwo ways to prove:\n- show greedy stays ahead always\n- exchange proof : given optimal solution exchange it to arrive at greedy\n\nGreedy problem: buildings and antennas\n- sort buildings by right endpoint\n- start at the leftmost right endpoint\n- keep going until a building's leftside is larger than previous antenna\n\t- set the next antenna to the next biggest right endpoint\n\nProof:\n- show that these antennas are blased on k buildings and these buildigns have no overlap\n- so we need at least k antennas for this \n- so by exchange proof: we have any solution is at least k, we have k so it is optimal\n\nTrails with happiness score and deadline\n- explore in reverse days from the end\n- add all trails that expire on that day to accessible list\n- explore the maximum one\n\nProof (exchange):\n- find the first spot from the end (latest spot) where the optimal sol. is different than the current one.\n\t- if it explores that trail at an earlier date then we can swap it with the current day\n\t- if it doesn't explore that trail then it's a contradiction because by construction, j, the item we chose, is the highest reward item acessible on that day\n\n## Dynamic programming \u0026 proof\n\n3D Knapsack\n- dp[v][w][i] -\u003e maximum score of item with value \u003c= v , weight \u003c= w, using items 1..i\n- for i..N : for v 0.. V : for w.. W : \n\t- if v \u003e vi and w \u003e wi : dp[v][w][i] = max (dp[v][w][i-1],pi +  dp[v-vi][w-wi][i-1] )\n\t- else:\n\nGoose eggs being dropped\n- DP[i][j] = x the number of drops required to figure it out with i floors and j eggs\n- dp[i][j] = min( max(dp[a][j-1], dp[i-a][j]) ) for all a\u003c=i\n\t\n### References\n1. \n\n---\nstatus: #ü¶¥  \ndate: 2022-04-15\ntags: [[Algorithms - CS 341]], [[Algorithms]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null},"/Zettelkasten/qqplot":{"title":"qqplot","content":"# qqplot\n![[Pasted image 20220126200215.png]]\nWe plot the observed quantile on the y axis and theoretical quantile on the x axis. A perfect fit is a perfect straight line, this plotting allows us to analyze the fit better since we only need to see how \"straight\" the line is.\n\nFor a normal distribution transforming from standardized (G(0, 1)) to whatever theoretical G(X, Y) is a matter of subtracting (mean) constant and dividing (deviation) which maintains the linearity of a slope. \n\nAnd so we can plot theoretical values (x axis) based on G(0, 1) \n![[Pasted image 20220126200557.png]]\n- This is powerful since we now don't have to estimate the mean or standard deviation of the sample to compare it to theoretical [[Gaussian distribution]]\n\nAt the tails there will be deviations in the tails since by definition as we approach the tail data points become less dense and so they vary more.\n\n## Skewness\nSkewness is reflected by the symmetry of the qqplot \n\nTails are reflected by where the data deviates away from the Gaussian line faster. If the upper right quadrant shoots up faster than the normal line then we know it has a denser right tail than the normal distribution.\n\n\n### References\n1. \n\n---\nstatus: #üå± \ndate: 2022-01-26\ntags: [[Statistics]], [[Statistics 241]]","lastmodified":"2022-08-19T04:48:18.82235315Z","tags":null}}